# 《瀛州纪》团队开发手册

> **版本**: 1.0.0  
> **最后更新**: 2025-10-26  
> **适用对象**: 全体开发团队成员

---

## 📚 目录

1. [项目概述](#项目概述)
2. [技术架构](#技术架构)
3. [开发环境搭建](#开发环境搭建)
4. [团队协作流程](#团队协作流程)
5. [代码规范](#代码规范)
6. [模块开发指南](#模块开发指南)
7. [测试与质量保证](#测试与质量保证)
8. [部署流程](#部署流程)
9. [常见问题](#常见问题)
10. [附录资源](#附录资源)

---

## 📖 项目概述

### 项目简介

《瀛州纪 (Immortal Ledger)》是一个创新的 **Web3 + AI 叙事游戏**，讲述了一个自我演化的数字生命文明从创世到毁灭的完整历史。

**核心特色**:
- 🔗 全链上文明：所有存在、交互、历史都记录在智能合约中
- 🤖 AI驱动叙事：AI-NPC根据世界状态生成动态对话
- 🎭 数字生命NFT：玩家即合约，每次交互都是链上交易
- 📜 不可篡改的历史：文明的记忆永久存储在区块链上
- 🌌 开放宇宙：游戏结束后，合约仍在链上，可继续扩展

### 项目目标

- **短期目标** (1-2周): 完善核心功能，接入AI服务，部署到测试网
- **中期目标** (1-2月): 添加DAO治理、多人交互、NFT市场
- **长期目标** (3-6月): 开发续作、跨链支持、考古模式

### 项目状态

✅ **已完成**:
- 智能合约层（WorldLedger, DigitalBeing, AINPC）
- 前端界面和核心组件
- AI对话系统基础框架
- 本地开发环境配置

⏳ **进行中**:
- AI服务集成优化
- 用户体验改进
- 性能优化

🔜 **待开发**:
- DAO治理系统
- 多人交互功能
- 移动端适配
- NFT市场集成

---

## 🏗️ 技术架构

### 技术栈

#### 区块链层
- **Solidity** 0.8.20 - 智能合约开发
- **Hardhat** 2.19+ - 开发框架
- **OpenZeppelin** 5.0 - 安全合约库
- **ethers.js** 6.9+ - Web3交互库

#### 前端层
- **Next.js** 14 - React框架（App Router）
- **TypeScript** 5.2+ - 类型安全
- **Tailwind CSS** 3.3+ - UI样式
- **Framer Motion** 10+ - 动画效果

#### AI层
- **魔搭/OpenAI** - AI对话服务
- **自定义提示工程** - 角色定制

### 系统架构图

```
┌─────────────────────────────────────────────────────────┐
│                      前端层 (Next.js)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │  页面组件     │  │  API路由     │  │  工具库      │ │
│  │  (React)     │  │  (AI Chat)   │  │  (Utils)     │ │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘ │
└─────────┼──────────────────┼──────────────────┼─────────┘
          │                  │                  │
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────┐
│                   Web3交互层 (ethers.js)                 │
└─────────────────────────────────────────────────────────┘
          │                                      │
          ▼                                      ▼
┌──────────────────────┐            ┌──────────────────────┐
│   区块链层 (Solidity) │            │    AI服务层          │
│  ┌────────────────┐  │            │  ┌────────────────┐ │
│  │ WorldLedger    │  │            │  │ 魔搭/OpenAI    │ │
│  │ DigitalBeing   │◄─┼────────────┼─►│ API服务        │ │
│  │ AINPC          │  │            │  └────────────────┘ │
│  └────────────────┘  │            └──────────────────────┘
└──────────────────────┘
```

### 数据流

```
用户操作 → React组件 → ethers.js → 智能合约
                  ↓
            AI API → 生成响应 → 链上记录 → 事件日志
                                      ↓
                              前端监听 → UI更新
```

---

## 💻 开发环境搭建

### 系统要求

- **操作系统**: Windows 10+, macOS 10.15+, Linux (Ubuntu 20.04+)
- **Node.js**: 18.0.0 或更高版本
- **npm**: 9.0.0 或更高版本
- **Git**: 2.30.0 或更高版本
- **浏览器**: Chrome/Edge 最新版 (需要 MetaMask 扩展)

### 环境配置步骤

#### 1. 克隆项目

```bash
# 克隆仓库
git clone <repository-url>
cd 瀛州纪

# 或者如果已有项目目录
cd "C:\Users\23157\CODE\Web3\刻熵Web3games-github仓库\Web3-games\瀛州纪"
```

#### 2. 安装依赖

```bash
# 安装所有依赖包
npm install

# 验证安装
npm list --depth=0
```

#### 3. 配置环境变量

创建 `.env.local` 文件：

```env
# 区块链配置
NEXT_PUBLIC_CHAIN_ID=31337
NEXT_PUBLIC_RPC_URL=http://127.0.0.1:8545

# 合约地址（部署后填写）
NEXT_PUBLIC_WORLD_LEDGER_ADDRESS=
NEXT_PUBLIC_DIGITAL_BEING_ADDRESS=
NEXT_PUBLIC_AINPC_ADDRESS=

# AI服务配置（可选）
AI_API_KEY=your_api_key_here
AI_API_URL=https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation
```

#### 4. 编译智能合约

```bash
# 编译所有合约
npm run compile

# 查看编译结果
ls artifacts/contracts/
```

#### 5. 启动本地区块链

```bash
# 在单独的终端中运行
npx hardhat node

# 保持此终端运行，记录测试账户信息
```

#### 6. 部署合约

```bash
# 在新终端中部署
npm run deploy

# 复制输出的合约地址到 .env.local
```

#### 7. 启动开发服务器

```bash
# 启动 Next.js 开发服务器
npm run dev

# 访问 http://localhost:3000
```

#### 8. 配置 MetaMask

1. 安装 MetaMask 浏览器扩展
2. 添加本地网络:
   - 网络名称: `Hardhat Local`
   - RPC URL: `http://127.0.0.1:8545`
   - 链ID: `31337`
   - 货币符号: `ETH`
3. 导入测试账户（使用 hardhat node 输出的私钥）

### 开发工具推荐

- **IDE**: VS Code + Solidity 扩展
- **调试**: Hardhat Console
- **API测试**: Postman/Insomnia
- **版本控制**: Git + GitHub Desktop
- **团队协作**: Discord/Slack

---

## 👥 团队协作流程

### 团队角色分工

#### 1. 智能合约开发者
**职责**:
- 编写和优化 Solidity 合约
- 编写合约测试
- 进行 Gas 优化
- 安全审计

**主要工作区域**:
- `contracts/` 目录
- `test/` 目录
- `scripts/` 目录

#### 2. 前端开发者
**职责**:
- 开发 React 组件
- 实现 Web3 集成
- UI/UX 优化
- 响应式设计

**主要工作区域**:
- `app/` 目录
- `components/` 目录
- `lib/` 目录（前端工具）

#### 3. AI工程师
**职责**:
- 设计和优化 AI 提示词
- 集成 AI 服务
- 实现衰变效果
- 对话质量优化

**主要工作区域**:
- `lib/ai.ts`
- `app/api/ai-chat/`
- `data/worldNarrative.json`

#### 4. 全栈开发者
**职责**:
- 跨层协调开发
- API 设计
- 性能优化
- 问题排查

**主要工作区域**:
- 所有目录

### Git 工作流

#### 分支策略

```
main (主分支)
  ├── develop (开发分支)
  │   ├── feature/contract-optimization (功能分支)
  │   ├── feature/ui-redesign
  │   ├── feature/ai-integration
  │   └── bugfix/wallet-connection
  └── release/v1.0.0 (发布分支)
```

#### 分支命名规范

- **功能分支**: `feature/功能名称`
  - 例: `feature/dao-governance`, `feature/nft-market`
- **修复分支**: `bugfix/问题描述`
  - 例: `bugfix/wallet-connection`, `bugfix/gas-estimation`
- **热修复**: `hotfix/紧急问题`
  - 例: `hotfix/contract-vulnerability`
- **发布分支**: `release/版本号`
  - 例: `release/v1.0.0`, `release/v1.1.0`

#### 工作流程

```bash
# 1. 从 develop 创建功能分支
git checkout develop
git pull origin develop
git checkout -b feature/new-feature

# 2. 开发并提交
git add .
git commit -m "feat: 添加新功能"

# 3. 推送到远程
git push origin feature/new-feature

# 4. 创建 Pull Request
# 在 GitHub 上创建 PR: feature/new-feature → develop

# 5. 代码审查通过后合并
# 由项目维护者合并

# 6. 删除本地分支
git checkout develop
git pull origin develop
git branch -d feature/new-feature
```

### 提交信息规范

使用 **Conventional Commits** 规范：

```
<类型>(<范围>): <简短描述>

<详细描述>

<footer>
```

**类型**:
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 重构
- `test`: 测试相关
- `chore`: 构建/工具相关

**示例**:

```bash
# 添加新功能
git commit -m "feat(contract): 添加DAO治理投票功能"

# 修复bug
git commit -m "fix(ui): 修复钱包连接断开问题"

# 文档更新
git commit -m "docs: 更新API文档说明"

# 重构代码
git commit -m "refactor(ai): 优化AI提示词生成逻辑"
```

### 代码审查流程

#### Pull Request 检查清单

提交 PR 前确保：

- [ ] 代码通过所有测试 (`npm test`)
- [ ] 代码符合规范（Lint检查）
- [ ] 添加了必要的注释
- [ ] 更新了相关文档
- [ ] 合约通过 Gas 分析
- [ ] 无安全漏洞
- [ ] UI 在主流浏览器测试通过

#### 审查标准

**智能合约审查**:
- 是否有安全漏洞
- Gas 优化是否合理
- 是否遵循最佳实践
- 测试覆盖率是否充分

**前端代码审查**:
- 组件是否可复用
- 性能是否优化
- 代码是否简洁易懂
- 是否有内存泄漏

**AI集成审查**:
- 提示词是否有效
- 错误处理是否完善
- 响应时间是否可接受
- 成本控制是否合理

### 日常协作

#### 每日站会
- **时间**: 每天上午 10:00（15分钟）
- **内容**:
  - 昨天完成了什么
  - 今天计划做什么
  - 遇到什么困难

#### 周会
- **时间**: 每周一上午 10:00（1小时）
- **内容**:
  - 上周进度回顾
  - 本周任务分配
  - 技术难点讨论
  - 项目规划调整

#### 沟通渠道
- **即时沟通**: Discord/Slack
- **代码讨论**: GitHub Issues/PR
- **文档协作**: Notion/飞书文档
- **任务管理**: GitHub Projects/Jira

---

## 📝 代码规范

### Solidity 规范

#### 命名规范

```solidity
// 合约名: PascalCase
contract WorldLedger { }
contract DigitalBeing { }

// 函数名: camelCase
function createBeing() external { }
function recordEvent() public { }

// 变量名: camelCase
uint256 public eventCounter;
address public worldGovernor;

// 常量: UPPER_SNAKE_CASE
uint256 public constant MAX_SUPPLY = 10000;
bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

// 枚举: PascalCase
enum WorldState { Genesis, Emergence, Flourish }

// 结构体: PascalCase
struct HistoricalEvent { }
```

#### 代码风格

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

/**
 * @title WorldLedger
 * @dev 世界账本合约 - 记录文明历史
 * @notice 此合约管理整个瀛州文明的状态
 */
contract WorldLedger {
    // 1. 类型声明
    enum WorldState { Genesis, Emergence, Flourish, Entropy, Collapsed }
    
    // 2. 状态变量
    WorldState public currentState;
    uint256 public eventCounter;
    
    // 3. 事件
    event StateChanged(WorldState oldState, WorldState newState);
    
    // 4. 修饰符
    modifier onlyGovernor() {
        require(msg.sender == worldGovernor, "Only governor");
        _;
    }
    
    // 5. 构造函数
    constructor() {
        currentState = WorldState.Genesis;
    }
    
    // 6. 外部函数
    function advanceState(WorldState newState) external onlyGovernor {
        // 实现逻辑
    }
    
    // 7. 公共函数
    function getState() public view returns (WorldState) {
        return currentState;
    }
    
    // 8. 内部函数
    function _updateState(WorldState newState) internal {
        // 实现逻辑
    }
    
    // 9. 私有函数
    function _validateState(WorldState state) private pure returns (bool) {
        // 实现逻辑
    }
}
```

#### 安全最佳实践

```solidity
// ✅ 使用 checks-effects-interactions 模式
function withdraw() external {
    // 1. Checks
    require(balances[msg.sender] > 0, "No balance");
    
    // 2. Effects
    uint256 amount = balances[msg.sender];
    balances[msg.sender] = 0;
    
    // 3. Interactions
    payable(msg.sender).transfer(amount);
}

// ✅ 使用 ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract MyContract is ReentrancyGuard {
    function sensitiveFunction() external nonReentrant {
        // 防止重入攻击
    }
}

// ✅ 使用 SafeMath（Solidity 0.8+ 内置）
uint256 result = a + b; // 自动溢出检查

// ✅ 输入验证
function setGovernor(address newGovernor) external {
    require(newGovernor != address(0), "Invalid address");
    require(msg.sender == currentGovernor, "Unauthorized");
    governor = newGovernor;
}
```

### TypeScript/React 规范

#### 命名规范

```typescript
// 组件名: PascalCase
export function DigitalBeingCard() { }
export function NPCList() { }

// 函数名: camelCase
function connectWallet() { }
function fetchEvents() { }

// 变量名: camelCase
const worldState = useState();
const isLoading = false;

// 常量: UPPER_SNAKE_CASE
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = "https://api.example.com";

// 接口/类型: PascalCase
interface BeingData { }
type EventType = "Creation" | "Interaction";

// 枚举: PascalCase
enum NPCType {
  Archivist,
  Architect,
  Mercantile
}
```

#### 组件结构

```typescript
'use client';

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';

// 1. 接口定义
interface DigitalBeingCardProps {
  address: string;
  onBeingCreated?: (id: number) => void;
}

interface BeingData {
  id: number;
  birthTime: number;
  memoryCount: number;
}

// 2. 组件定义
export function DigitalBeingCard({ 
  address, 
  onBeingCreated 
}: DigitalBeingCardProps) {
  // 3. State hooks
  const [beingData, setBeingData] = useState<BeingData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string>('');

  // 4. Effect hooks
  useEffect(() => {
    loadBeingData();
  }, [address]);

  // 5. 事件处理函数
  const handleCreateBeing = async () => {
    try {
      setIsLoading(true);
      // 创建逻辑
      onBeingCreated?.(newId);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  // 6. 辅助函数
  const loadBeingData = async () => {
    // 加载逻辑
  };

  // 7. 渲染
  return (
    <div className="being-card">
      {/* JSX */}
    </div>
  );
}
```

#### Hooks 使用规范

```typescript
// ✅ 自定义 Hook
function useContract(contractName: string) {
  const [contract, setContract] = useState<ethers.Contract | null>(null);
  
  useEffect(() => {
    const loadContract = async () => {
      // 加载合约逻辑
    };
    loadContract();
  }, [contractName]);
  
  return contract;
}

// ✅ 使用示例
function MyComponent() {
  const worldLedger = useContract('WorldLedger');
  
  // ...
}
```

### 样式规范

```typescript
// ✅ 使用 Tailwind CSS 类
<div className="flex items-center justify-between p-4 bg-gray-900 rounded-lg">
  <h2 className="text-xl font-bold text-cyan-400">标题</h2>
</div>

// ✅ 复杂样式使用 @apply
// globals.css
.card-base {
  @apply p-6 bg-gray-800 rounded-lg border border-cyan-500/30;
}

// ✅ 动画使用 Framer Motion
import { motion } from 'framer-motion';

<motion.div
  initial={{ opacity: 0, y: 20 }}
  animate={{ opacity: 1, y: 0 }}
  transition={{ duration: 0.5 }}
>
  内容
</motion.div>
```

### 注释规范

```typescript
/**
 * 创建数字生命 NFT
 * @param address 接收者地址
 * @returns 新创建的 Being ID
 * @throws 如果地址无效或已存在 Being
 */
async function createBeing(address: string): Promise<number> {
  // 验证地址格式
  if (!ethers.isAddress(address)) {
    throw new Error('Invalid address');
  }

  // 调用合约
  const tx = await digitalBeing.createBeing(address);
  const receipt = await tx.wait();

  // 解析事件获取 ID
  const event = receipt.logs.find(/* ... */);
  return event.args.id;
}
```

---

## 🔧 模块开发指南

### 智能合约开发

#### 创建新合约

1. **在 `contracts/` 目录创建新文件**

```solidity
// contracts/NewFeature.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./WorldLedger.sol";

contract NewFeature {
    WorldLedger public worldLedger;
    
    constructor(address _worldLedger) {
        worldLedger = WorldLedger(_worldLedger);
    }
    
    // 实现功能...
}
```

2. **编写测试**

```javascript
// test/NewFeature.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("NewFeature", function () {
  let newFeature, worldLedger, owner;

  beforeEach(async function () {
    [owner] = await ethers.getSigners();
    
    // 部署依赖合约
    const WorldLedger = await ethers.getContractFactory("WorldLedger");
    worldLedger = await WorldLedger.deploy();
    
    // 部署新合约
    const NewFeature = await ethers.getContractFactory("NewFeature");
    newFeature = await NewFeature.deploy(await worldLedger.getAddress());
  });

  it("应该正确初始化", async function () {
    expect(await newFeature.worldLedger()).to.equal(await worldLedger.getAddress());
  });

  // 更多测试...
});
```

3. **更新部署脚本**

```javascript
// scripts/deploy.js
const newFeature = await NewFeature.deploy(worldLedger.address);
console.log("NewFeature deployed to:", await newFeature.getAddress());
```

4. **导出 ABI**

```bash
npm run export-abi
```

#### Gas 优化技巧

```solidity
// ❌ 避免：循环中的存储读取
for (uint256 i = 0; i < array.length; i++) {
    total += array[i];  // 每次循环都读取 storage
}

// ✅ 优化：缓存到内存
uint256 length = array.length;
for (uint256 i = 0; i < length; i++) {
    total += array[i];
}

// ❌ 避免：频繁修改 storage
function updateMultiple(uint256[] memory values) external {
    for (uint256 i = 0; i < values.length; i++) {
        data[i] = values[i];  // 多次 SSTORE
    }
}

// ✅ 优化：批量操作
function updateMultiple(uint256[] memory values) external {
    // 使用事件记录而不是存储
    emit DataUpdated(values);
}

// ✅ 使用 unchecked 避免不必要的溢出检查
function increment(uint256 x) pure returns (uint256) {
    unchecked {
        return x + 1;  // 确定不会溢出时使用
    }
}
```

### 前端组件开发

#### 创建新组件

1. **创建组件文件**

```typescript
// components/NewComponent.tsx
'use client';

import React, { useState } from 'react';
import { motion } from 'framer-motion';

interface NewComponentProps {
  title: string;
  onAction?: () => void;
}

export function NewComponent({ title, onAction }: NewComponentProps) {
  const [isActive, setIsActive] = useState(false);

  return (
    <motion.div
      className="p-6 bg-gray-800 rounded-lg border border-cyan-500/30"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
    >
      <h3 className="text-xl font-bold text-cyan-400 mb-4">
        {title}
      </h3>
      {/* 组件内容 */}
    </motion.div>
  );
}
```

2. **在页面中使用**

```typescript
// app/page.tsx
import { NewComponent } from '@/components/NewComponent';

export default function Page() {
  return (
    <div>
      <NewComponent title="新功能" onAction={() => console.log('action')} />
    </div>
  );
}
```

#### Web3 集成模式

```typescript
// 1. 获取合约实例
import { getContract } from '@/lib/contracts';

const worldLedger = await getContract('WorldLedger', provider);

// 2. 读取数据
const currentState = await worldLedger.currentState();
const entropy = await worldLedger.getEntropyLevel();

// 3. 写入交易
const tx = await worldLedger.connect(signer).recordEvent(
  eventType,
  contentHash,
  metadata
);
const receipt = await tx.wait();

// 4. 监听事件
worldLedger.on('EventRecorded', (eventId, eventType, actor) => {
  console.log('New event:', eventId);
  // 更新UI
});

// 5. 错误处理
try {
  await worldLedger.someFunction();
} catch (error) {
  if (error.code === 'ACTION_REJECTED') {
    console.log('User rejected transaction');
  } else if (error.code === 'INSUFFICIENT_FUNDS') {
    console.log('Insufficient balance');
  } else {
    console.error('Transaction failed:', error);
  }
}
```

### AI 集成开发

#### 自定义 NPC 提示词

```typescript
// lib/ai.ts
const NPC_PROMPTS = {
  Archivist: `你是瀛州文明的史官...`,
  NewNPC: `你是一个新的 NPC 角色...
  
你的特点：
- 特点1
- 特点2

回答风格：
- 简洁明了
- 富有哲理

当前世界状态：{worldState}
熵化程度：{entropyLevel}%
  `
};
```

#### 处理 AI 响应

```typescript
// app/api/ai-chat/route.ts
export async function POST(request: Request) {
  const { npcType, message, worldState } = await request.json();

  try {
    // 获取提示词
    const systemPrompt = getNPCPrompt(npcType, worldState);

    // 调用 AI API
    const response = await fetch(AI_API_URL, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${AI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'qwen-plus',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: message }
        ]
      })
    });

    const data = await response.json();
    
    return Response.json({
      success: true,
      response: data.output.text
    });
  } catch (error) {
    return Response.json({
      success: false,
      error: error.message
    }, { status: 500 });
  }
}
```

---

## 🧪 测试与质量保证

### 智能合约测试

#### 测试结构

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("WorldLedger", function () {
  // 测试变量
  let worldLedger, digitalBeing, ainpc;
  let owner, addr1, addr2;

  // 每个测试前执行
  beforeEach(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    
    // 部署合约
    const WorldLedger = await ethers.getContractFactory("WorldLedger");
    worldLedger = await WorldLedger.deploy();
    
    const DigitalBeing = await ethers.getContractFactory("DigitalBeing");
    digitalBeing = await DigitalBeing.deploy(await worldLedger.getAddress());
    
    // 注册 DigitalBeing 合约
    await worldLedger.registerDigitalBeing(await digitalBeing.getAddress());
  });

  describe("初始化", function () {
    it("应该设置正确的初始状态", async function () {
      expect(await worldLedger.currentState()).to.equal(0); // Genesis
      expect(await worldLedger.isFinalized()).to.equal(false);
    });

    it("应该设置部署者为 governor", async function () {
      expect(await worldLedger.worldGovernor()).to.equal(owner.address);
    });
  });

  describe("记录事件", function () {
    it("应该成功记录事件", async function () {
      const contentHash = ethers.keccak256(ethers.toUtf8Bytes("test event"));
      const metadata = JSON.stringify({ type: "test" });

      await expect(
        worldLedger.connect(owner).recordEvent(0, contentHash, metadata)
      ).to.emit(worldLedger, "EventRecorded");

      const event = await worldLedger.events(1);
      expect(event.contentHash).to.equal(contentHash);
    });

    it("未授权用户不能记录事件", async function () {
      const contentHash = ethers.keccak256(ethers.toUtf8Bytes("test"));
      
      await expect(
        worldLedger.connect(addr1).recordEvent(0, contentHash, "{}")
      ).to.be.revertedWith("Only digital beings can interact");
    });
  });

  describe("状态转换", function () {
    it("应该能推进世界状态", async function () {
      await worldLedger.advanceState(1); // Emergence
      expect(await worldLedger.currentState()).to.equal(1);
    });

    it("非 governor 不能推进状态", async function () {
      await expect(
        worldLedger.connect(addr1).advanceState(1)
      ).to.be.revertedWith("Only governor can call");
    });
  });

  describe("熵化机制", function () {
    it("应该正确计算熵化程度", async function () {
      // 推进到 Entropy 状态
      await worldLedger.advanceState(3);
      
      // 模拟时间流逝
      await ethers.provider.send("evm_mine", []);
      
      const entropyLevel = await worldLedger.getEntropyLevel();
      expect(entropyLevel).to.be.gt(0);
    });
  });
});
```

#### 运行测试

```bash
# 运行所有测试
npm test

# 运行特定测试文件
npx hardhat test test/WorldLedger.test.js

# 查看测试覆盖率
npx hardhat coverage

# Gas 报告
REPORT_GAS=true npx hardhat test
```

### 前端测试

#### 组件测试（Jest + React Testing Library）

```typescript
// __tests__/DigitalBeingCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { DigitalBeingCard } from '@/components/DigitalBeingCard';

describe('DigitalBeingCard', () => {
  it('应该渲染组件', () => {
    render(<DigitalBeingCard address="0x123..." />);
    expect(screen.getByText(/数字生命/i)).toBeInTheDocument();
  });

  it('应该处理创建操作', async () => {
    const onCreated = jest.fn();
    render(<DigitalBeingCard address="0x123..." onBeingCreated={onCreated} />);
    
    const button = screen.getByText(/创建/i);
    fireEvent.click(button);
    
    // 等待异步操作
    await screen.findByText(/创建成功/i);
    expect(onCreated).toHaveBeenCalled();
  });
});
```

### 集成测试

```typescript
// 测试完整流程
describe('游戏流程集成测试', () => {
  it('应该完成完整的游戏流程', async () => {
    // 1. 连接钱包
    await connectWallet();
    
    // 2. 创建数字生命
    const beingId = await createBeing();
    expect(beingId).toBeGreaterThan(0);
    
    // 3. 与 NPC 交互
    const response = await interactWithNPC('Archivist', '你好');
    expect(response).toBeDefined();
    
    // 4. 查看历史事件
    const events = await fetchEvents();
    expect(events.length).toBeGreaterThan(0);
  });
});
```

### 质量检查清单

部署前检查：

- [ ] 所有单元测试通过
- [ ] 集成测试通过
- [ ] Gas 消耗在合理范围
- [ ] 无安全漏洞（使用 Slither 检查）
- [ ] 代码覆盖率 > 80%
- [ ] 所有 TypeScript 类型检查通过
- [ ] 无 Lint 错误
- [ ] 浏览器兼容性测试通过
- [ ] 移动端响应式测试通过

---

## 🚀 部署流程

### 部署前准备

#### 1. 环境检查

```bash
# 检查 Node 版本
node --version  # 应该 >= 18

# 检查依赖
npm list --depth=0

# 编译合约
npm run compile

# 运行测试
npm test

# 构建前端
npm run build
```

#### 2. 配置生产环境变量

创建 `.env.production`:

```env
# 测试网配置
PRIVATE_KEY=your_private_key
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY
ETHERSCAN_API_KEY=your_etherscan_key

# AI 服务
AI_API_KEY=your_production_api_key
AI_API_URL=https://your-ai-service.com/api
```

### 部署到测试网（Sepolia）

#### 1. 获取测试币

- 访问 [Sepolia Faucet](https://sepoliafaucet.com/)
- 获取至少 0.5 ETH 用于部署

#### 2. 更新 Hardhat 配置

```javascript
// hardhat.config.js
require('dotenv').config();

module.exports = {
  networks: {
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [process.env.PRIVATE_KEY],
      chainId: 11155111
    }
  }
};
```

#### 3. 部署合约

```bash
# 部署到 Sepolia
npx hardhat run scripts/deploy.js --network sepolia

# 记录输出的合约地址
```

#### 4. 验证合约

```bash
npx hardhat verify --network sepolia <WorldLedger地址>
npx hardhat verify --network sepolia <DigitalBeing地址> <WorldLedger地址>
npx hardhat verify --network sepolia <AINPC地址> <WorldLedger地址>
```

### 部署前端（Vercel）

#### 1. 准备仓库

```bash
# 确保代码已提交
git add .
git commit -m "chore: 准备部署"
git push origin main
```

#### 2. 配置 Vercel

1. 访问 [vercel.com](https://vercel.com)
2. 导入 GitHub 仓库
3. 配置环境变量：
   - `NEXT_PUBLIC_CHAIN_ID=11155111`
   - `NEXT_PUBLIC_RPC_URL=你的RPC_URL`
   - `NEXT_PUBLIC_WORLD_LEDGER_ADDRESS=...`
   - `NEXT_PUBLIC_DIGITAL_BEING_ADDRESS=...`
   - `NEXT_PUBLIC_AINPC_ADDRESS=...`
   - `AI_API_KEY=...`

4. 点击部署

#### 3. 验证部署

- 访问 Vercel 提供的 URL
- 测试钱包连接
- 测试核心功能
- 检查控制台错误

### 部署到主网（谨慎）

⚠️ **警告**: 主网部署需要真实的 ETH，请确保：
- 代码经过充分测试
- 进行安全审计
- Gas 优化完成
- 有足够的资金

```bash
# 1. 配置主网
# hardhat.config.js
mainnet: {
  url: process.env.MAINNET_RPC_URL,
  accounts: [process.env.MAINNET_PRIVATE_KEY],
  chainId: 1
}

# 2. 部署
npx hardhat run scripts/deploy.js --network mainnet

# 3. 验证
npx hardhat verify --network mainnet <合约地址>
```

### 部署后任务

- [ ] 更新文档中的合约地址
- [ ] 在 README 中添加测试网链接
- [ ] 创建使用教程
- [ ] 公告部署信息
- [ ] 监控合约活动
- [ ] 设置告警（Gas 价格、交易失败等）

---

## ❓ 常见问题

### 开发环境问题

#### Q1: `npm install` 失败

**解决方案**:
```bash
# 清除缓存
npm cache clean --force

# 删除 node_modules 和 lock 文件
rm -rf node_modules package-lock.json

# 重新安装
npm install
```

#### Q2: Hardhat 编译错误

**解决方案**:
```bash
# 清除 artifacts 和 cache
npx hardhat clean

# 重新编译
npx hardhat compile

# 如果还有问题，检查 Solidity 版本是否一致
```

#### Q3: MetaMask 连接失败

**解决方案**:
- 确保 MetaMask 已解锁
- 检查网络是否正确（localhost:8545 或 Sepolia）
- 重置 MetaMask 账户（设置 → 高级 → 重置账户）
- 清除浏览器缓存

### 合约交互问题

#### Q4: Gas 估算失败

**可能原因**:
1. 函数调用条件不满足（require 失败）
2. 权限不足
3. 合约状态不允许

**调试方法**:
```javascript
// 使用 callStatic 模拟调用
try {
  await worldLedger.callStatic.someFunction(params);
} catch (error) {
  console.log("模拟调用失败:", error);
}
```

#### Q5: 交易被 revert

**解决方案**:
```javascript
// 捕获详细错误信息
try {
  const tx = await contract.someFunction();
  await tx.wait();
} catch (error) {
  if (error.reason) {
    console.log("Revert reason:", error.reason);
  }
  if (error.data) {
    // 解析自定义错误
    console.log("Error data:", error.data);
  }
}
```

### AI 集成问题

#### Q6: AI 响应超时

**解决方案**:
```typescript
// 增加超时时间
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒

try {
  const response = await fetch(AI_API_URL, {
    signal: controller.signal,
    // ...
  });
} finally {
  clearTimeout(timeoutId);
}
```

#### Q7: AI 返回内容质量差

**优化提示词**:
```typescript
const improvedPrompt = `
你是瀛州文明的史官，一个链上数字生命。

背景：
- 你存在于一个纯逻辑构成的世界
- 你的记忆存储在区块链上
- 你见证了文明的兴衰

当前状态：
- 世界纪元：${worldState}
- 熵化程度：${entropyLevel}%

回答要求：
1. 使用诗意但精确的语言
2. 融入代码和逻辑的隐喻
3. 回答长度：50-150字
4. 如果熵化程度高，回答要包含一些矛盾或模糊的内容

用户问题：${question}
`;
```

### 性能问题

#### Q8: 页面加载慢

**优化方案**:
```typescript
// 1. 懒加载组件
const DialogueInterface = dynamic(
  () => import('@/components/DialogueInterface'),
  { ssr: false }
);

// 2. 缓存合约调用
const [cachedData, setCachedData] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    if (cachedData) return cachedData;
    const data = await contract.getData();
    setCachedData(data);
  };
  fetchData();
}, []);

// 3. 批量请求
const [state, entropy, events] = await Promise.all([
  worldLedger.currentState(),
  worldLedger.getEntropyLevel(),
  worldLedger.getRecentEvents(10)
]);
```

#### Q9: Gas 费用过高

**优化合约**:
```solidity
// 使用事件代替存储
event DataRecorded(uint256 indexed id, bytes data);

// 批量操作
function batchRecordEvents(EventData[] calldata events) external {
    for (uint256 i = 0; i < events.length; i++) {
        _recordEvent(events[i]);
    }
}

// 使用紧凑的数据类型
struct CompactData {
    uint32 timestamp;  // 而不是 uint256
    uint16 value;
    uint8 state;
}
```

### 部署问题

#### Q10: Vercel 部署失败

**检查清单**:
- [ ] `package.json` 中的构建命令正确
- [ ] 所有环境变量已配置
- [ ] 没有使用 Node.js 特定 API（如 `fs`）在客户端
- [ ] 图片和静态资源路径正确

#### Q11: 合约验证失败

**解决方案**:
```bash
# 使用 flatten 合并合约
npx hardhat flatten contracts/WorldLedger.sol > WorldLedger_flat.sol

# 手动在 Etherscan 上验证
# 选择对应的编译器版本和优化设置
```

---

## 📚 附录资源

### 相关文档

- [README.md](./README.md) - 项目概述
- [快速开始指南.md](./快速开始指南.md) - 5分钟上手
- [DEPLOYMENT.md](./DEPLOYMENT.md) - 详细部署说明
- [PROJECT_STRUCTURE.md](./PROJECT_STRUCTURE.md) - 项目结构
- [CONTRIBUTING.md](./CONTRIBUTING.md) - 贡献指南
- [游戏思路.md](./游戏思路.md) - 设计理念

### 技术文档

#### Solidity / Hardhat
- [Solidity 官方文档](https://docs.soliditylang.org/)
- [Hardhat 文档](https://hardhat.org/docs)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts)
- [Ethers.js 文档](https://docs.ethers.org/v6/)

#### Next.js / React
- [Next.js 官方文档](https://nextjs.org/docs)
- [React 文档](https://react.dev/)
- [TypeScript 手册](https://www.typescriptlang.org/docs/)
- [Tailwind CSS 文档](https://tailwindcss.com/docs)

#### AI 服务
- [魔搭平台文档](https://www.modelscope.cn/docs)
- [OpenAI API 文档](https://platform.openai.com/docs)

### 开发工具

#### IDE 和扩展
- **VS Code**: 推荐 IDE
- **Solidity**: 智能合约高亮
- **ESLint**: 代码检查
- **Prettier**: 代码格式化
- **GitLens**: Git 增强

#### 调试工具
- **Hardhat Console**: 合约交互
  ```bash
  npx hardhat console --network localhost
  ```
- **Remix IDE**: 在线合约开发
- **Tenderly**: 交易调试
- **React DevTools**: React 组件调试

#### 安全工具
- **Slither**: 静态分析
  ```bash
  pip install slither-analyzer
  slither contracts/
  ```
- **Mythril**: 安全扫描
- **OpenZeppelin Defender**: 合约监控

### 学习资源

#### 视频教程
- [Hardhat 入门教程](https://www.youtube.com/watch?v=...)
- [Next.js 13 完整课程](https://www.youtube.com/watch?v=...)
- [Web3 开发实战](https://www.youtube.com/watch?v=...)

#### 书籍推荐
- 《精通以太坊》
- 《Solidity 编程实战》
- 《React 进阶之路》

#### 社区
- [Hardhat Discord](https://discord.gg/hardhat)
- [Ethereum StackExchange](https://ethereum.stackexchange.com/)
- [Next.js Discussions](https://github.com/vercel/next.js/discussions)

### 项目模板

```bash
# 创建新功能的模板
# 1. 合约模板
contracts/templates/Feature.sol

# 2. 组件模板
components/templates/Component.tsx

# 3. 测试模板
test/templates/Feature.test.js
```

### 代码片段

#### VS Code Snippets

```json
{
  "Solidity Contract": {
    "prefix": "sol-contract",
    "body": [
      "// SPDX-License-Identifier: MIT",
      "pragma solidity ^0.8.20;",
      "",
      "/**",
      " * @title ${1:ContractName}",
      " * @dev ${2:Description}",
      " */",
      "contract ${1:ContractName} {",
      "    ${3}",
      "}"
    ]
  },
  "React Component": {
    "prefix": "tsx-component",
    "body": [
      "'use client';",
      "",
      "import React from 'react';",
      "",
      "interface ${1:Component}Props {",
      "  ${2:prop}: ${3:string};",
      "}",
      "",
      "export function ${1:Component}({ ${2:prop} }: ${1:Component}Props) {",
      "  return (",
      "    <div>",
      "      ${4}",
      "    </div>",
      "  );",
      "}"
    ]
  }
}
```

### 有用的命令

```bash
# 开发常用命令
npm run dev          # 启动开发服务器
npm run build        # 构建生产版本
npm test             # 运行测试
npm run compile      # 编译合约
npm run deploy       # 部署合约

# Git 常用命令
git status           # 查看状态
git add .            # 添加所有更改
git commit -m "msg"  # 提交
git push             # 推送
git pull             # 拉取
git checkout -b feat # 创建分支

# Hardhat 常用命令
npx hardhat compile  # 编译
npx hardhat test     # 测试
npx hardhat node     # 启动本地节点
npx hardhat console  # 进入控制台
npx hardhat clean    # 清理缓存

# 调试命令
npm run dev -- --turbo  # 使用 Turbopack
npm run build && npm start  # 生产模式
```

### 项目路线图

#### 第一阶段（已完成）
- [x] 基础架构搭建
- [x] 核心合约开发
- [x] 前端界面实现
- [x] AI 基础集成

#### 第二阶段（进行中）
- [ ] AI 服务优化
- [ ] 性能优化
- [ ] 测试网部署
- [ ] 用户文档完善

#### 第三阶段（规划中）
- [ ] DAO 治理
- [ ] 多人交互
- [ ] NFT 市场
- [ ] 移动端

#### 第四阶段（未来）
- [ ] 跨链支持
- [ ] 续作开发
- [ ] 考古模式
- [ ] 社区生态

### 联系方式

- **项目仓库**: [GitHub](https://github.com/...)
- **问题反馈**: [Issues](https://github.com/.../issues)
- **讨论社区**: [Discussions](https://github.com/.../discussions)
- **团队邮箱**: team@yingzhou.example

---

## 📄 附录：快速参考

### 环境变量速查

```env
# 本地开发
NEXT_PUBLIC_CHAIN_ID=31337
NEXT_PUBLIC_RPC_URL=http://127.0.0.1:8545

# Sepolia 测试网
NEXT_PUBLIC_CHAIN_ID=11155111
NEXT_PUBLIC_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY

# 主网（谨慎使用）
NEXT_PUBLIC_CHAIN_ID=1
NEXT_PUBLIC_RPC_URL=https://mainnet.infura.io/v3/YOUR_KEY
```

### 合约地址速查

```typescript
// lib/contracts.ts
export const CONTRACT_ADDRESSES = {
  localhost: {
    WorldLedger: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
    DigitalBeing: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512',
    AINPC: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0'
  },
  sepolia: {
    WorldLedger: '待部署',
    DigitalBeing: '待部署',
    AINPC: '待部署'
  }
};
```

### 常用正则表达式

```typescript
// 以太坊地址
const ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;

// 交易哈希
const TX_HASH_REGEX = /^0x[a-fA-F0-9]{64}$/;

// ENS 域名
const ENS_REGEX = /^[a-z0-9-]+\.eth$/;
```

---

## 🎯 下一步行动

### 新成员入职
1. 阅读本手册
2. 完成环境搭建
3. 运行本地开发环境
4. 完成一个小任务（如修改 UI 文字）
5. 提交第一个 PR

### 开始新功能开发
1. 在 GitHub Issues 创建功能提案
2. 团队讨论并分配任务
3. 创建功能分支
4. 开发并测试
5. 提交 PR 并进行代码审查
6. 合并到 develop 分支

### 报告问题
1. 检查是否已有相同问题
2. 收集错误信息和复现步骤
3. 在 Issues 中详细描述
4. 添加相关标签（bug/enhancement/question）

---

**祝开发顺利！** 🚀

如有任何问题，请随时联系团队或查阅相关文档。

---

*最后更新：2025-10-26*  
*版本：1.0.0*  
*维护者：《瀛州纪》开发团队*

