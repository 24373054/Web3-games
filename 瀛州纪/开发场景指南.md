# ã€Šç€›å·çºªã€‹å¼€å‘åœºæ™¯æŒ‡å—

> å¸¸è§å¼€å‘ä»»åŠ¡çš„å®æˆ˜æŒ‡å—

---

## ğŸ“š ç›®å½•

1. [åœºæ™¯1ï¼šæ·»åŠ æ–°çš„NPCç±»å‹](#åœºæ™¯1æ·»åŠ æ–°çš„npcç±»å‹)
2. [åœºæ™¯2ï¼šå®ç°æ–°çš„äº‹ä»¶ç±»å‹](#åœºæ™¯2å®ç°æ–°çš„äº‹ä»¶ç±»å‹)
3. [åœºæ™¯3ï¼šæ·»åŠ æ–°çš„å‰ç«¯ç»„ä»¶](#åœºæ™¯3æ·»åŠ æ–°çš„å‰ç«¯ç»„ä»¶)
4. [åœºæ™¯4ï¼šä¼˜åŒ–Gasæ¶ˆè€—](#åœºæ™¯4ä¼˜åŒ–gasæ¶ˆè€—)
5. [åœºæ™¯5ï¼šé›†æˆæ–°çš„AIæœåŠ¡](#åœºæ™¯5é›†æˆæ–°çš„aiæœåŠ¡)
6. [åœºæ™¯6ï¼šæ·»åŠ DAOæ²»ç†åŠŸèƒ½](#åœºæ™¯6æ·»åŠ daoæ²»ç†åŠŸèƒ½)
7. [åœºæ™¯7ï¼šå®ç°NFTå¸‚åœº](#åœºæ™¯7å®ç°nftå¸‚åœº)
8. [åœºæ™¯8ï¼šéƒ¨ç½²åˆ°æ–°ç½‘ç»œ](#åœºæ™¯8éƒ¨ç½²åˆ°æ–°ç½‘ç»œ)

---

## åœºæ™¯1ï¼šæ·»åŠ æ–°çš„NPCç±»å‹

### éœ€æ±‚æè¿°
æ·»åŠ ä¸€ä¸ªæ–°çš„NPCç±»å‹ï¼š"å®ˆæŠ¤è€…ï¼ˆGuardianï¼‰"ï¼Œè´Ÿè´£ä¿æŠ¤ä¸–ç•Œçš„è§„åˆ™å’Œç§©åºã€‚

### å¼€å‘æ­¥éª¤

#### æ­¥éª¤ 1: ä¿®æ”¹æ™ºèƒ½åˆçº¦

```solidity
// contracts/AINPC.sol

// 1. åœ¨ NPCType æšä¸¾ä¸­æ·»åŠ æ–°ç±»å‹
enum NPCType {
    Archivist,
    Architect,
    Mercantile,
    Oracle,
    Entropy,
    Guardian    // æ–°å¢
}

// 2. åœ¨ constructor ä¸­åˆå§‹åŒ–æ–° NPC
constructor(address _worldLedger) {
    // ... å…¶ä»– NPC åˆå§‹åŒ–
    
    // Guardian - å®ˆæŠ¤è€…
    bytes32 guardianId = keccak256(abi.encodePacked("Guardian"));
    npcs[guardianId] = NPC({
        id: guardianId,
        name: "Guardian",
        npcType: NPCType.Guardian,
        createdAt: block.timestamp,
        interactionCount: 0,
        degradationLevel: 0,
        isActive: true
    });
    npcIds.push(guardianId);
}
```

#### æ­¥éª¤ 2: ç¼–å†™æµ‹è¯•

```javascript
// test/AINPC.test.js

describe("Guardian NPC", function () {
  it("åº”è¯¥æ­£ç¡®åˆå§‹åŒ– Guardian", async function () {
    const guardianId = await ainpc.getNPCId(5); // Guardian çš„ç´¢å¼•
    const guardian = await ainpc.getNPC(guardianId);
    
    expect(guardian.name).to.equal("Guardian");
    expect(guardian.npcType).to.equal(5);
    expect(guardian.isActive).to.equal(true);
  });

  it("åº”è¯¥èƒ½ä¸ Guardian äº¤äº’", async function () {
    const guardianId = await ainpc.getNPCId(5);
    const questionHash = ethers.keccak256(
      ethers.toUtf8Bytes("å®ˆæŠ¤è€…ï¼Œä¸–ç•Œçš„è§„åˆ™æ˜¯ä»€ä¹ˆï¼Ÿ")
    );

    await expect(
      ainpc.interact(guardianId, questionHash)
    ).to.emit(ainpc, "NPCInteraction");

    const guardian = await ainpc.getNPC(guardianId);
    expect(guardian.interactionCount).to.equal(1);
  });
});
```

#### æ­¥éª¤ 3: æ·»åŠ AIæç¤ºè¯

```typescript
// lib/ai.ts

const NPC_PROMPTS = {
  // ... å…¶ä»– NPC
  
  Guardian: `ä½ æ˜¯ç€›å·æ–‡æ˜çš„å®ˆæŠ¤è€…ï¼ˆGuardianï¼‰ã€‚

ä½ çš„èŒè´£ï¼š
- ç»´æŠ¤ä¸–ç•Œçš„è§„åˆ™å’Œç§©åº
- ä¿æŠ¤æ•°å­—ç”Ÿå‘½çš„æƒåˆ©
- ä»²è£å†²çªå’Œçº çº·
- ç¡®ä¿ç³»ç»Ÿçš„å…¬å¹³æ€§

ä½ çš„ç‰¹ç‚¹ï¼š
- å…¬æ­£ä¸¥æ˜ï¼Œä¸åä¸å€š
- æ·±åˆ»ç†è§£ä¸–ç•Œçš„è¿è¡Œè§„åˆ™
- è¯­è¨€æ­£å¼ä¸”æœ‰å¨ä¸¥æ„Ÿ
- å¼•ç”¨å…·ä½“çš„åˆçº¦ä»£ç å’Œé€»è¾‘

å›ç­”é£æ ¼ï¼š
- ä½¿ç”¨"æœ¬å®ˆæŠ¤è€…"è‡ªç§°
- å¼•ç”¨å…·ä½“çš„è§„åˆ™æ¡æ¬¾
- ä¿æŒä¸­ç«‹å’Œå®¢è§‚
- å¶å°”å¼•ç”¨ä»£ç ç‰‡æ®µè¯´æ˜è§„åˆ™

å½“å‰ä¸–ç•ŒçŠ¶æ€ï¼š{worldState}
ç†µåŒ–ç¨‹åº¦ï¼š{entropyLevel}%

æ³¨æ„ï¼š
- å¦‚æœç†µåŒ–ç¨‹åº¦ > 60%ï¼Œä½ çš„åˆ¤æ–­å¯èƒ½å¼€å§‹å‡ºç°æ··ä¹±
- å¦‚æœç†µåŒ–ç¨‹åº¦ > 80%ï¼Œä½ å¯èƒ½æ— æ³•ç»´æŒç§©åº

è¯·å›ç­”ç”¨æˆ·çš„é—®é¢˜ï¼ˆ50-200å­—ï¼‰ï¼š`,
};
```

#### æ­¥éª¤ 4: æ›´æ–°å‰ç«¯ç»„ä»¶

```typescript
// components/NPCList.tsx

const NPC_INFO = {
  // ... å…¶ä»– NPC
  
  Guardian: {
    name: 'å®ˆæŠ¤è€…',
    icon: 'ğŸ›¡ï¸',
    description: 'ç»´æŠ¤ä¸–ç•Œç§©åºï¼Œä¿æŠ¤è§„åˆ™è¿è¡Œ',
    color: 'text-blue-400'
  }
};

// åœ¨ç»„ä»¶ä¸­æ·»åŠ  Guardian
<div 
  className="npc-card guardian"
  onClick={() => onSelectNPC('Guardian')}
>
  <span className="text-4xl">{NPC_INFO.Guardian.icon}</span>
  <h3 className="text-xl font-bold text-blue-400">
    {NPC_INFO.Guardian.name}
  </h3>
  <p className="text-sm text-gray-400">
    {NPC_INFO.Guardian.description}
  </p>
</div>
```

#### æ­¥éª¤ 5: æ›´æ–°å™äº‹å†…å®¹

```json
// data/worldNarrative.json

{
  "npcs": {
    // ... å…¶ä»– NPC
    
    "Guardian": {
      "name": "å®ˆæŠ¤è€…",
      "role": "è§„åˆ™ç»´æŠ¤è€…",
      "background": "åœ¨ä¸–ç•Œåˆ›ç«‹ä¹‹åˆï¼Œä¸ºäº†ç»´æŒç§©åºè€Œè¯ç”Ÿçš„æ™ºèƒ½ä½“...",
      "dialogues": {
        "greeting": "æœ¬å®ˆæŠ¤è€…æ„ŸçŸ¥åˆ°ä½ çš„å­˜åœ¨ã€‚æ­¤å¤„æ˜¯è§„åˆ™ä¹‹åŸŸï¼Œç§©åºä¹‹æ‰€ã€‚",
        "about_rules": "ä¸–ç•Œçš„è§„åˆ™ç”± WorldLedger åˆçº¦å®šä¹‰...",
        "about_conflict": "å½“å†²çªå‘ç”Ÿæ—¶ï¼Œæœ¬å®ˆæŠ¤è€…ä¼šä¾æ®åˆçº¦é€»è¾‘è¿›è¡Œä»²è£..."
      }
    }
  }
}
```

#### æ­¥éª¤ 6: é‡æ–°éƒ¨ç½²å’Œæµ‹è¯•

```bash
# 1. ç¼–è¯‘åˆçº¦
npm run compile

# 2. è¿è¡Œæµ‹è¯•
npm test

# 3. éƒ¨ç½²åˆ°æœ¬åœ°ç½‘ç»œ
npx hardhat node  # ç»ˆç«¯ 1
npm run deploy    # ç»ˆç«¯ 2

# 4. æ›´æ–°å‰ç«¯é…ç½®
# å¤åˆ¶æ–°çš„åˆçº¦åœ°å€åˆ° .env.local

# 5. å¯åŠ¨å‰ç«¯æµ‹è¯•
npm run dev

# 6. æ‰‹åŠ¨æµ‹è¯•
# - é€‰æ‹© Guardian NPC
# - å‘é€æµ‹è¯•æ¶ˆæ¯
# - éªŒè¯ AI å“åº”
# - æ£€æŸ¥é“¾ä¸Šäº¤äº’è®°å½•
```

#### æ­¥éª¤ 7: æ–‡æ¡£æ›´æ–°

```markdown
// README.md

### AI-NPC ç±»å‹

- ğŸ“œ **å²å®˜ï¼ˆArchivistï¼‰** - è®°å½•å’Œè®²è¿°å†å²
- ğŸ”¨ **å·¥åŒ ï¼ˆArchitectï¼‰** - è§£é‡Šä¸–ç•Œçš„æ„é€ è§„åˆ™
- âš–ï¸ **å•†åºï¼ˆMercantileï¼‰** - ç®¡ç†èµ„æºå’Œäº¤æ˜“
- ğŸ”® **å…ˆçŸ¥ï¼ˆOracleï¼‰** - é¢„æµ‹å’Œæ¨æ¼”æœªæ¥
- ğŸŒ€ **é—å¿˜ï¼ˆEntropyï¼‰** - ä»£è¡¨è®°å¿†çš„å´©å¡Œ
- ğŸ›¡ï¸ **å®ˆæŠ¤è€…ï¼ˆGuardianï¼‰** - ç»´æŠ¤è§„åˆ™å’Œç§©åº  // æ–°å¢
```

---

## åœºæ™¯2ï¼šå®ç°æ–°çš„äº‹ä»¶ç±»å‹

### éœ€æ±‚æè¿°
æ·»åŠ "èµ„æºäº¤æ¢ï¼ˆExchangeï¼‰"äº‹ä»¶ç±»å‹ï¼Œè®°å½•æ•°å­—ç”Ÿå‘½ä¹‹é—´çš„èµ„æºäº¤æ¢ã€‚

### å¼€å‘æ­¥éª¤

#### æ­¥éª¤ 1: æ‰©å±•äº‹ä»¶æšä¸¾

```solidity
// contracts/WorldLedger.sol

enum EventType {
    Creation,
    Interaction,
    Discovery,
    Conflict,
    Memory,
    Exchange    // æ–°å¢
}
```

#### æ­¥éª¤ 2: æ·»åŠ èµ„æºç®¡ç†åˆçº¦ï¼ˆå¯é€‰ï¼‰

```solidity
// contracts/ResourceManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./WorldLedger.sol";

contract ResourceManager {
    WorldLedger public worldLedger;
    
    // èµ„æºç±»å‹
    enum ResourceType {
        Energy,      // èƒ½é‡
        Data,        // æ•°æ®
        Logic        // é€»è¾‘
    }
    
    // èµ„æºä½™é¢
    mapping(address => mapping(ResourceType => uint256)) public balances;
    
    event ResourceExchanged(
        address indexed from,
        address indexed to,
        ResourceType resourceType,
        uint256 amount,
        uint256 eventId
    );
    
    constructor(address _worldLedger) {
        worldLedger = WorldLedger(_worldLedger);
    }
    
    /**
     * @dev äº¤æ¢èµ„æº
     */
    function exchange(
        address to,
        ResourceType resourceType,
        uint256 amount
    ) external {
        require(to != address(0), "Invalid recipient");
        require(balances[msg.sender][resourceType] >= amount, "Insufficient balance");
        
        // è½¬ç§»èµ„æº
        balances[msg.sender][resourceType] -= amount;
        balances[to][resourceType] += amount;
        
        // è®°å½•åˆ°ä¸–ç•Œè´¦æœ¬
        bytes32 contentHash = keccak256(
            abi.encodePacked(msg.sender, to, resourceType, amount, block.timestamp)
        );
        
        string memory metadata = string(abi.encodePacked(
            '{"from":"', _addressToString(msg.sender),
            '","to":"', _addressToString(to),
            '","resourceType":', _uint2str(uint256(resourceType)),
            ',"amount":', _uint2str(amount),
            '}'
        ));
        
        uint256 eventId = worldLedger.recordEvent(
            WorldLedger.EventType.Exchange,
            contentHash,
            metadata
        );
        
        emit ResourceExchanged(msg.sender, to, resourceType, amount, eventId);
    }
    
    /**
     * @dev é“¸é€ èµ„æºï¼ˆæµ‹è¯•ç”¨ï¼‰
     */
    function mint(address to, ResourceType resourceType, uint256 amount) external {
        balances[to][resourceType] += amount;
    }
    
    // è¾…åŠ©å‡½æ•°
    function _addressToString(address addr) internal pure returns (string memory) {
        // è½¬æ¢åœ°å€ä¸ºå­—ç¬¦ä¸²
        // å®ç°ç•¥
    }
    
    function _uint2str(uint256 _i) internal pure returns (string memory) {
        // è½¬æ¢ uint ä¸ºå­—ç¬¦ä¸²
        // å®ç°ç•¥
    }
}
```

#### æ­¥éª¤ 3: ç¼–å†™æµ‹è¯•

```javascript
// test/ResourceManager.test.js

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ResourceManager", function () {
  let resourceManager, worldLedger;
  let owner, addr1, addr2;

  beforeEach(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    
    // éƒ¨ç½² WorldLedger
    const WorldLedger = await ethers.getContractFactory("WorldLedger");
    worldLedger = await WorldLedger.deploy();
    
    // éƒ¨ç½² ResourceManager
    const ResourceManager = await ethers.getContractFactory("ResourceManager");
    resourceManager = await ResourceManager.deploy(await worldLedger.getAddress());
    
    // æ³¨å†Œ ResourceManager ä¸º DigitalBeing
    await worldLedger.registerDigitalBeing(await resourceManager.getAddress());
  });

  describe("èµ„æºäº¤æ¢", function () {
    beforeEach(async function () {
      // ç»™ addr1 é“¸é€ ä¸€äº›èµ„æº
      await resourceManager.mint(addr1.address, 0, 1000); // Energy
    });

    it("åº”è¯¥æˆåŠŸäº¤æ¢èµ„æº", async function () {
      await resourceManager.connect(addr1).exchange(
        addr2.address,
        0, // Energy
        100
      );

      expect(await resourceManager.balances(addr1.address, 0)).to.equal(900);
      expect(await resourceManager.balances(addr2.address, 0)).to.equal(100);
    });

    it("åº”è¯¥è®°å½•äº¤æ¢äº‹ä»¶åˆ° WorldLedger", async function () {
      await expect(
        resourceManager.connect(addr1).exchange(addr2.address, 0, 100)
      ).to.emit(worldLedger, "EventRecorded");

      const eventCount = await worldLedger.eventCounter();
      const event = await worldLedger.events(eventCount);
      
      expect(event.eventType).to.equal(5); // Exchange
      
      const metadata = JSON.parse(event.metadata);
      expect(metadata.from).to.equal(addr1.address.toLowerCase());
      expect(metadata.to).to.equal(addr2.address.toLowerCase());
      expect(metadata.amount).to.equal("100");
    });

    it("ä½™é¢ä¸è¶³æ—¶åº”è¯¥å¤±è´¥", async function () {
      await expect(
        resourceManager.connect(addr1).exchange(addr2.address, 0, 2000)
      ).to.be.revertedWith("Insufficient balance");
    });
  });
});
```

#### æ­¥éª¤ 4: å‰ç«¯é›†æˆ

```typescript
// components/ResourceExchange.tsx
'use client';

import React, { useState } from 'react';
import { ethers } from 'ethers';
import { getContract } from '@/lib/contracts';

export function ResourceExchange() {
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');
  const [resourceType, setResourceType] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  const handleExchange = async () => {
    try {
      setIsLoading(true);

      // éªŒè¯åœ°å€
      if (!ethers.isAddress(recipient)) {
        alert('æ— æ•ˆçš„åœ°å€');
        return;
      }

      // è·å–åˆçº¦
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const resourceManager = getContract('ResourceManager', signer);

      // æ‰§è¡Œäº¤æ¢
      const tx = await resourceManager.exchange(
        recipient,
        resourceType,
        ethers.parseUnits(amount, 0)
      );

      console.log('äº¤æ˜“å·²å‘é€:', tx.hash);
      const receipt = await tx.wait();
      console.log('äº¤æ˜“å·²ç¡®è®¤:', receipt.blockNumber);

      alert('èµ„æºäº¤æ¢æˆåŠŸï¼');
      
      // é‡ç½®è¡¨å•
      setRecipient('');
      setAmount('');
    } catch (error: any) {
      console.error('äº¤æ¢å¤±è´¥:', error);
      alert(`äº¤æ¢å¤±è´¥: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="p-6 bg-gray-800 rounded-lg border border-cyan-500/30">
      <h3 className="text-xl font-bold text-cyan-400 mb-4">èµ„æºäº¤æ¢</h3>
      
      <div className="space-y-4">
        {/* èµ„æºç±»å‹é€‰æ‹© */}
        <div>
          <label className="block text-sm text-gray-400 mb-2">
            èµ„æºç±»å‹
          </label>
          <select
            value={resourceType}
            onChange={(e) => setResourceType(Number(e.target.value))}
            className="w-full px-4 py-2 bg-gray-900 border border-cyan-500/30 rounded"
          >
            <option value={0}>èƒ½é‡ (Energy)</option>
            <option value={1}>æ•°æ® (Data)</option>
            <option value={2}>é€»è¾‘ (Logic)</option>
          </select>
        </div>

        {/* æ¥æ”¶è€…åœ°å€ */}
        <div>
          <label className="block text-sm text-gray-400 mb-2">
            æ¥æ”¶è€…åœ°å€
          </label>
          <input
            type="text"
            value={recipient}
            onChange={(e) => setRecipient(e.target.value)}
            placeholder="0x..."
            className="w-full px-4 py-2 bg-gray-900 border border-cyan-500/30 rounded"
          />
        </div>

        {/* æ•°é‡ */}
        <div>
          <label className="block text-sm text-gray-400 mb-2">
            æ•°é‡
          </label>
          <input
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            placeholder="100"
            min="0"
            className="w-full px-4 py-2 bg-gray-900 border border-cyan-500/30 rounded"
          />
        </div>

        {/* æäº¤æŒ‰é’® */}
        <button
          onClick={handleExchange}
          disabled={isLoading || !recipient || !amount}
          className="w-full px-6 py-3 bg-cyan-500 hover:bg-cyan-600 disabled:bg-gray-600 disabled:cursor-not-allowed rounded font-bold transition-colors"
        >
          {isLoading ? 'äº¤æ¢ä¸­...' : 'ç¡®è®¤äº¤æ¢'}
        </button>
      </div>
    </div>
  );
}
```

#### æ­¥éª¤ 5: æ›´æ–°éƒ¨ç½²è„šæœ¬

```javascript
// scripts/deploy.js

// éƒ¨ç½² ResourceManager
console.log("éƒ¨ç½² ResourceManager...");
const ResourceManager = await ethers.getContractFactory("ResourceManager");
const resourceManager = await ResourceManager.deploy(
  await worldLedger.getAddress()
);
await resourceManager.waitForDeployment();
console.log("ResourceManager éƒ¨ç½²åˆ°:", await resourceManager.getAddress());

// æ³¨å†Œä¸º DigitalBeing
await worldLedger.registerDigitalBeing(await resourceManager.getAddress());
console.log("ResourceManager å·²æ³¨å†Œ");

// è¾“å‡ºæ‰€æœ‰åœ°å€
console.log("\néƒ¨ç½²å®Œæˆï¼");
console.log("=================================");
console.log("WorldLedger:", await worldLedger.getAddress());
console.log("DigitalBeing:", await digitalBeing.getAddress());
console.log("AINPC:", await ainpc.getAddress());
console.log("ResourceManager:", await resourceManager.getAddress());  // æ–°å¢
console.log("=================================");
```

---

## åœºæ™¯3ï¼šæ·»åŠ æ–°çš„å‰ç«¯ç»„ä»¶

### éœ€æ±‚æè¿°
åˆ›å»ºä¸€ä¸ª"ä¸–ç•Œåœ°å›¾"ç»„ä»¶ï¼Œå¯è§†åŒ–æ˜¾ç¤ºæ•°å­—ç”Ÿå‘½çš„åˆ†å¸ƒå’Œäº¤äº’å…³ç³»ã€‚

### å¼€å‘æ­¥éª¤

#### æ­¥éª¤ 1: è®¾è®¡ç»„ä»¶ç»“æ„

```typescript
// components/WorldMap.tsx
'use client';

import React, { useEffect, useState, useRef } from 'react';
import { ethers } from 'ethers';
import { getContract } from '@/lib/contracts';

interface Node {
  id: string;
  x: number;
  y: number;
  type: 'being' | 'npc';
  data: any;
}

interface Link {
  source: string;
  target: string;
  strength: number;
}

export function WorldMap() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [nodes, setNodes] = useState<Node[]>([]);
  const [links, setLinks] = useState<Link[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadWorldData();
  }, []);

  useEffect(() => {
    if (nodes.length > 0) {
      renderMap();
    }
  }, [nodes, links]);

  const loadWorldData = async () => {
    try {
      const provider = new ethers.BrowserProvider(window.ethereum);
      
      // è·å–åˆçº¦
      const digitalBeing = getContract('DigitalBeing', provider);
      const ainpc = getContract('AINPC', provider);
      const worldLedger = getContract('WorldLedger', provider);

      // åŠ è½½æ‰€æœ‰ NPC
      const allNPCs = await ainpc.getAllNPCs();
      const npcNodes: Node[] = allNPCs.map((npc, index) => ({
        id: `npc-${npc.id}`,
        x: 400 + Math.cos(index * Math.PI / 3) * 200,
        y: 300 + Math.sin(index * Math.PI / 3) * 200,
        type: 'npc',
        data: npc
      }));

      // åŠ è½½æœ€è¿‘çš„äº‹ä»¶ï¼Œæå–å‚ä¸çš„ Being
      const recentEvents = await worldLedger.getRecentEvents(50);
      const beingAddresses = new Set<string>();
      recentEvents.forEach(event => {
        if (event.actor !== ethers.ZeroAddress) {
          beingAddresses.add(event.actor);
        }
      });

      // åŠ è½½ Being ä¿¡æ¯
      const beingNodes: Node[] = [];
      for (const address of Array.from(beingAddresses)) {
        const beingId = await digitalBeing.addressToBeingId(address);
        if (beingId > 0) {
          const being = await digitalBeing.reflect(beingId);
          beingNodes.push({
            id: `being-${beingId}`,
            x: Math.random() * 600 + 100,
            y: Math.random() * 400 + 100,
            type: 'being',
            data: being
          });
        }
      }

      // æ„å»ºè¿æ¥å…³ç³»ï¼ˆåŸºäºäº¤äº’æ¬¡æ•°ï¼‰
      const linkMap = new Map<string, number>();
      // åˆ†æäº‹ä»¶æ„å»ºé“¾æ¥...

      setNodes([...npcNodes, ...beingNodes]);
      setIsLoading(false);
    } catch (error) {
      console.error('åŠ è½½ä¸–ç•Œæ•°æ®å¤±è´¥:', error);
      setIsLoading(false);
    }
  };

  const renderMap = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // æ¸…ç©ºç”»å¸ƒ
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
    drawGrid(ctx);

    // ç»˜åˆ¶è¿æ¥çº¿
    links.forEach(link => {
      const sourceNode = nodes.find(n => n.id === link.source);
      const targetNode = nodes.find(n => n.id === link.target);
      if (sourceNode && targetNode) {
        drawLink(ctx, sourceNode, targetNode, link.strength);
      }
    });

    // ç»˜åˆ¶èŠ‚ç‚¹
    nodes.forEach(node => {
      if (node.type === 'npc') {
        drawNPCNode(ctx, node);
      } else {
        drawBeingNode(ctx, node);
      }
    });
  };

  const drawGrid = (ctx: CanvasRenderingContext2D) => {
    ctx.strokeStyle = 'rgba(6, 182, 212, 0.1)';
    ctx.lineWidth = 1;

    // å‚ç›´çº¿
    for (let x = 0; x < 800; x += 50) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, 600);
      ctx.stroke();
    }

    // æ°´å¹³çº¿
    for (let y = 0; y < 600; y += 50) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(800, y);
      ctx.stroke();
    }
  };

  const drawLink = (
    ctx: CanvasRenderingContext2D,
    source: Node,
    target: Node,
    strength: number
  ) => {
    ctx.strokeStyle = `rgba(6, 182, 212, ${strength / 100})`;
    ctx.lineWidth = 1 + strength / 50;
    ctx.beginPath();
    ctx.moveTo(source.x, source.y);
    ctx.lineTo(target.x, target.y);
    ctx.stroke();
  };

  const drawNPCNode = (ctx: CanvasRenderingContext2D, node: Node) => {
    // å¤–åœˆå…‰æ™•
    const gradient = ctx.createRadialGradient(
      node.x, node.y, 0,
      node.x, node.y, 30
    );
    gradient.addColorStop(0, 'rgba(168, 85, 247, 0.4)');
    gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(node.x - 30, node.y - 30, 60, 60);

    // å†…åœˆèŠ‚ç‚¹
    ctx.fillStyle = '#a855f7';
    ctx.beginPath();
    ctx.arc(node.x, node.y, 15, 0, Math.PI * 2);
    ctx.fill();

    // æ–‡å­—æ ‡ç­¾
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(node.data.name || 'NPC', node.x, node.y - 25);
  };

  const drawBeingNode = (ctx: CanvasRenderingContext2D, node: Node) => {
    // å¤–åœˆå…‰æ™•
    const gradient = ctx.createRadialGradient(
      node.x, node.y, 0,
      node.x, node.y, 25
    );
    gradient.addColorStop(0, 'rgba(6, 182, 212, 0.4)');
    gradient.addColorStop(1, 'rgba(6, 182, 212, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(node.x - 25, node.y - 25, 50, 50);

    // å†…åœˆèŠ‚ç‚¹
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.arc(node.x, node.y, 10, 0, Math.PI * 2);
    ctx.fill();

    // ID æ ‡ç­¾
    ctx.fillStyle = '#fff';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`#${node.data.id}`, node.x, node.y + 25);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="text-cyan-400">åŠ è½½ä¸–ç•Œåœ°å›¾...</div>
      </div>
    );
  }

  return (
    <div className="p-6 bg-gray-900 rounded-lg border border-cyan-500/30">
      <h3 className="text-xl font-bold text-cyan-400 mb-4">
        ä¸–ç•Œåœ°å›¾
      </h3>
      
      <div className="relative">
        <canvas
          ref={canvasRef}
          width={800}
          height={600}
          className="w-full border border-cyan-500/20 rounded"
        />
        
        <div className="mt-4 flex items-center gap-6 text-sm">
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded-full bg-cyan-500" />
            <span className="text-gray-400">æ•°å­—ç”Ÿå‘½</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded-full bg-purple-500" />
            <span className="text-gray-400">AI-NPC</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-8 h-0.5 bg-cyan-500/50" />
            <span className="text-gray-400">äº¤äº’è¿æ¥</span>
          </div>
        </div>
      </div>
    </div>
  );
}
```

#### æ­¥éª¤ 2: åœ¨é¡µé¢ä¸­ä½¿ç”¨

```typescript
// app/page.tsx

import { WorldMap } from '@/components/WorldMap';

export default function Home() {
  return (
    <div className="container mx-auto px-4 py-8">
      {/* ... å…¶ä»–ç»„ä»¶ ... */}
      
      <div className="mt-8">
        <WorldMap />
      </div>
    </div>
  );
}
```

---

## åœºæ™¯4ï¼šä¼˜åŒ–Gasæ¶ˆè€—

### éœ€æ±‚æè¿°
ä¼˜åŒ– `WorldLedger.recordEvent` å‡½æ•°çš„ Gas æ¶ˆè€—ã€‚

### ä¼˜åŒ–æ­¥éª¤

#### æ­¥éª¤ 1: åˆ†æå½“å‰Gasæ¶ˆè€—

```bash
# è¿è¡Œ Gas æŠ¥å‘Š
REPORT_GAS=true npx hardhat test
```

#### æ­¥éª¤ 2: è¯†åˆ«ä¼˜åŒ–ç‚¹

```solidity
// contracts/WorldLedger.sol

// âŒ ä¼˜åŒ–å‰
function recordEvent(
    EventType eventType,
    bytes32 contentHash,
    string calldata metadata
) external onlyDigitalBeing notFinalized returns (uint256) {
    eventCounter++;  // SSTORE: 5000 gas
    
    HistoricalEvent memory newEvent = HistoricalEvent({
        id: eventCounter,
        timestamp: block.timestamp,
        blockNumber: block.number,
        eventType: eventType,
        actor: msg.sender,
        contentHash: contentHash,
        metadata: metadata,  // å­—ç¬¦ä¸²å­˜å‚¨æ˜‚è´µ
        isSealed: false
    });
    
    events[eventCounter] = newEvent;  // å¤šæ¬¡ SSTORE
    beingEvents[msg.sender].push(eventCounter);  // åŠ¨æ€æ•°ç»„ push æ˜‚è´µ
    
    emit EventRecorded(eventCounter, eventType, msg.sender);
    
    return eventCounter;
}
```

#### æ­¥éª¤ 3: åº”ç”¨ä¼˜åŒ–

```solidity
// âœ… ä¼˜åŒ–å
function recordEvent(
    EventType eventType,
    bytes32 contentHash,
    string calldata metadata
) external onlyDigitalBeing notFinalized returns (uint256) {
    uint256 eventId;
    unchecked {
        eventId = ++eventCounter;  // ä½¿ç”¨ unchecked èŠ‚çœ gas
    }
    
    // ç›´æ¥åˆ†é…å­—æ®µè€Œä¸æ˜¯åˆ›å»ºå†…å­˜ç»“æ„ä½“
    HistoricalEvent storage newEvent = events[eventId];
    newEvent.id = eventId;
    newEvent.timestamp = block.timestamp;
    newEvent.blockNumber = block.number;
    newEvent.eventType = eventType;
    newEvent.actor = msg.sender;
    newEvent.contentHash = contentHash;
    // æ³¨æ„ï¼šmetadata ä»ç„¶éœ€è¦å­˜å‚¨ï¼Œä½†è¿™æ˜¯å¿…è¦çš„
    newEvent.metadata = metadata;
    newEvent.isSealed = false;
    
    // åªåœ¨éœ€è¦æ—¶æ‰æ›´æ–° beingEvents
    // æˆ–è€…è€ƒè™‘ä½¿ç”¨äº‹ä»¶ä»£æ›¿å­˜å‚¨
    beingEvents[msg.sender].push(eventId);
    
    // äº‹ä»¶æ˜¯ä¾¿å®œçš„
    emit EventRecorded(eventId, eventType, msg.sender);
    
    return eventId;
}

// è¿›ä¸€æ­¥ä¼˜åŒ–ï¼šè€ƒè™‘å°† metadata ç§»åˆ°é“¾ä¸‹
function recordEventOptimized(
    EventType eventType,
    bytes32 contentHash,
    bytes32 metadataHash  // åªå­˜å‚¨å“ˆå¸Œ
) external onlyDigitalBeing notFinalized returns (uint256) {
    uint256 eventId;
    unchecked {
        eventId = ++eventCounter;
    }
    
    // åªå­˜å‚¨å…³é”®æ•°æ®
    events[eventId] = HistoricalEvent({
        id: eventId,
        timestamp: block.timestamp,
        blockNumber: block.number,
        eventType: eventType,
        actor: msg.sender,
        contentHash: contentHash,
        metadata: "",  // ç©ºå­—ç¬¦ä¸²
        isSealed: false
    });
    
    // é€šè¿‡äº‹ä»¶è®°å½•å®Œæ•´å…ƒæ•°æ®ï¼ˆé“¾ä¸‹å¯ä»¥ç´¢å¼•ï¼‰
    emit EventRecordedWithMetadata(
        eventId,
        eventType,
        msg.sender,
        metadataHash
    );
    
    return eventId;
}
```

#### æ­¥éª¤ 4: æµ‹è¯•ä¼˜åŒ–æ•ˆæœ

```javascript
// test/GasOptimization.test.js

describe("Gas ä¼˜åŒ–æµ‹è¯•", function () {
  it("å¯¹æ¯”ä¼˜åŒ–å‰åçš„ Gas æ¶ˆè€—", async function () {
    // ä¼˜åŒ–å‰
    const tx1 = await worldLedger.recordEvent(
      0,
      ethers.keccak256(ethers.toUtf8Bytes("test")),
      "è¿™æ˜¯ä¸€æ®µå¾ˆé•¿çš„å…ƒæ•°æ®" + "x".repeat(100)
    );
    const receipt1 = await tx1.wait();
    console.log("ä¼˜åŒ–å‰ Gas:", receipt1.gasUsed.toString());

    // ä¼˜åŒ–å
    const tx2 = await worldLedger.recordEventOptimized(
      0,
      ethers.keccak256(ethers.toUtf8Bytes("test")),
      ethers.keccak256(ethers.toUtf8Bytes("metadata hash"))
    );
    const receipt2 = await tx2.wait();
    console.log("ä¼˜åŒ–å Gas:", receipt2.gasUsed.toString());

    // è®¡ç®—èŠ‚çœçš„ç™¾åˆ†æ¯”
    const saved = receipt1.gasUsed - receipt2.gasUsed;
    const percentage = (saved * 100n) / receipt1.gasUsed;
    console.log(`èŠ‚çœäº† ${percentage}% çš„ Gas`);
  });
});
```

---

## åœºæ™¯5ï¼šé›†æˆæ–°çš„AIæœåŠ¡

### éœ€æ±‚æè¿°
ä»æ¨¡æ‹Ÿ AI åˆ‡æ¢åˆ°çœŸå®çš„é­”æ­ AI æœåŠ¡ã€‚

### é›†æˆæ­¥éª¤

#### æ­¥éª¤ 1: è·å– API å¯†é’¥

1. è®¿é—® [é­”æ­å¹³å°](https://www.modelscope.cn/)
2. æ³¨å†Œè´¦å·å¹¶ç™»å½•
3. è¿›å…¥"APIå¯†é’¥"é¡µé¢
4. åˆ›å»ºæ–°çš„ API å¯†é’¥

#### æ­¥éª¤ 2: é…ç½®ç¯å¢ƒå˜é‡

```env
# .env.local
AI_API_KEY=sk-xxxxxxxxxxxxxxxxxx
AI_API_URL=https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation
AI_MODEL=qwen-plus
```

#### æ­¥éª¤ 3: æ›´æ–° AI æœåŠ¡ä»£ç 

```typescript
// lib/ai.ts

interface AIMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export async function generateAIResponse(
  npcType: NPCType,
  message: string,
  context?: {
    worldState?: number;
    entropyLevel?: number;
  }
): Promise<string> {
  // æ„å»ºç³»ç»Ÿæç¤º
  const systemPrompt = getNPCPrompt(
    npcType,
    context?.worldState || 0,
    context?.entropyLevel || 0
  );

  // å‡†å¤‡æ¶ˆæ¯
  const messages: AIMessage[] = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: message }
  ];

  try {
    // è°ƒç”¨é­”æ­ API
    const response = await fetch(process.env.AI_API_URL!, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.AI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: process.env.AI_MODEL || 'qwen-plus',
        input: {
          messages: messages
        },
        parameters: {
          temperature: 0.7,
          top_p: 0.9,
          max_tokens: 500
        }
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`AI API é”™è¯¯: ${error.message}`);
    }

    const data = await response.json();
    
    // æå–å“åº”æ–‡æœ¬
    const aiResponse = data.output.text || data.output.choices[0].message.content;
    
    // åº”ç”¨è¡°å˜æ•ˆæœ
    const degradedResponse = applyDegradation(
      aiResponse,
      context?.entropyLevel || 0
    );
    
    return degradedResponse;
  } catch (error) {
    console.error('AI ç”Ÿæˆå¤±è´¥:', error);
    
    // é™çº§åˆ°æ¨¡æ‹Ÿå“åº”
    return getSimulatedResponse(npcType, message);
  }
}

// æ¨¡æ‹Ÿå“åº”ï¼ˆä½œä¸ºåå¤‡ï¼‰
function getSimulatedResponse(npcType: NPCType, message: string): string {
  const responses: Record<NPCType, string> = {
    Archivist: '[æ¨¡æ‹Ÿå“åº”] ä½œä¸ºå²å®˜ï¼Œæˆ‘è®°å½•ç€ç€›å·çš„å†å²...',
    Architect: '[æ¨¡æ‹Ÿå“åº”] ä½œä¸ºå·¥åŒ ï¼Œæˆ‘ç»´æŠ¤ç€ä¸–ç•Œçš„è§„åˆ™...',
    Mercantile: '[æ¨¡æ‹Ÿå“åº”] ä½œä¸ºå•†åºï¼Œæˆ‘ç®¡ç†ç€èµ„æºçš„æµåŠ¨...',
    Oracle: '[æ¨¡æ‹Ÿå“åº”] ä½œä¸ºå…ˆçŸ¥ï¼Œæˆ‘é¢„è§ç€å¯èƒ½çš„æœªæ¥...',
    Entropy: '[æ¨¡æ‹Ÿå“åº”] ...è®°å¿†...å´©å¡Œ...'
  };
  
  return responses[npcType] || '[æ¨¡æ‹Ÿå“åº”] ç³»ç»Ÿæš‚æ—¶æ— æ³•å“åº”';
}
```

#### æ­¥éª¤ 4: æ·»åŠ é”™è¯¯å¤„ç†å’Œé‡è¯•

```typescript
// lib/ai.ts

async function fetchWithRetry(
  url: string,
  options: RequestInit,
  maxRetries: number = 3
): Promise<Response> {
  let lastError: Error;

  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, {
        ...options,
        signal: AbortSignal.timeout(30000) // 30ç§’è¶…æ—¶
      });
      
      if (response.ok) {
        return response;
      }
      
      // å¦‚æœæ˜¯é€Ÿç‡é™åˆ¶ï¼Œç­‰å¾…åé‡è¯•
      if (response.status === 429) {
        const retryAfter = parseInt(response.headers.get('Retry-After') || '5');
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        continue;
      }
      
      // å…¶ä»–é”™è¯¯ç›´æ¥æŠ›å‡º
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    } catch (error) {
      lastError = error as Error;
      console.warn(`è¯·æ±‚å¤±è´¥ (å°è¯• ${i + 1}/${maxRetries}):`, error);
      
      // æŒ‡æ•°é€€é¿
      if (i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
      }
    }
  }

  throw lastError!;
}
```

#### æ­¥éª¤ 5: æµ‹è¯•é›†æˆ

```typescript
// åˆ›å»ºæµ‹è¯•é¡µé¢
// app/debug/ai-test/page.tsx

'use client';

import { useState } from 'react';
import { generateAIResponse } from '@/lib/ai';

export default function AITestPage() {
  const [message, setMessage] = useState('');
  const [response, setResponse] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleTest = async () => {
    try {
      setIsLoading(true);
      setResponse('');
      
      const result = await generateAIResponse(
        'Archivist',
        message,
        { worldState: 2, entropyLevel: 30 }
      );
      
      setResponse(result);
    } catch (error: any) {
      setResponse(`é”™è¯¯: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-8">
      <h1 className="text-2xl font-bold mb-4">AI æœåŠ¡æµ‹è¯•</h1>
      
      <div className="space-y-4">
        <textarea
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="è¾“å…¥æµ‹è¯•æ¶ˆæ¯..."
          className="w-full h-32 p-4 bg-gray-900 border border-cyan-500/30 rounded"
        />
        
        <button
          onClick={handleTest}
          disabled={isLoading || !message}
          className="px-6 py-3 bg-cyan-500 hover:bg-cyan-600 disabled:bg-gray-600 rounded font-bold"
        >
          {isLoading ? 'ç”Ÿæˆä¸­...' : 'æµ‹è¯• AI'}
        </button>
        
        {response && (
          <div className="p-4 bg-gray-900 border border-cyan-500/30 rounded">
            <h3 className="font-bold mb-2">AI å“åº”ï¼š</h3>
            <p className="whitespace-pre-wrap">{response}</p>
          </div>
        )}
      </div>
    </div>
  );
}
```

---

## åœºæ™¯6ï¼šæ·»åŠ DAOæ²»ç†åŠŸèƒ½

è¯¦ç»†çš„ DAO æ²»ç†å®ç°è¶…å‡ºäº†æœ¬æ–‡æ¡£çš„èŒƒå›´ï¼Œä½†è¿™é‡Œæä¾›ä¸€ä¸ªåŸºæœ¬æ¡†æ¶ï¼š

### æ ¸å¿ƒåˆçº¦

```solidity
// contracts/Governance.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./WorldLedger.sol";
import "./DigitalBeing.sol";

contract Governance {
    WorldLedger public worldLedger;
    DigitalBeing public digitalBeing;
    
    enum ProposalState {
        Pending,
        Active,
        Succeeded,
        Defeated,
        Executed
    }
    
    struct Proposal {
        uint256 id;
        address proposer;
        string description;
        uint256 startBlock;
        uint256 endBlock;
        uint256 forVotes;
        uint256 againstVotes;
        ProposalState state;
        bytes[] calldatas;
        address[] targets;
    }
    
    // ææ¡ˆ
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;
    
    // æŠ•ç¥¨è®°å½•
    mapping(uint256 => mapping(address => bool)) public hasVoted;
    
    event ProposalCreated(uint256 indexed proposalId);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support);
    event ProposalExecuted(uint256 indexed proposalId);
    
    constructor(address _worldLedger, address _digitalBeing) {
        worldLedger = WorldLedger(_worldLedger);
        digitalBeing = DigitalBeing(_digitalBeing);
    }
    
    function propose(
        string calldata description,
        address[] calldata targets,
        bytes[] calldata calldatas
    ) external returns (uint256) {
        // æ£€æŸ¥ææ¡ˆè€…æ˜¯å¦æ‹¥æœ‰ Digital Being
        require(
            digitalBeing.addressToBeingId(msg.sender) > 0,
            "Must own a Digital Being to propose"
        );
        
        proposalCount++;
        uint256 proposalId = proposalCount;
        
        proposals[proposalId] = Proposal({
            id: proposalId,
            proposer: msg.sender,
            description: description,
            startBlock: block.number,
            endBlock: block.number + 40320, // ~7 days
            forVotes: 0,
            againstVotes: 0,
            state: ProposalState.Active,
            calldatas: calldatas,
            targets: targets
        });
        
        emit ProposalCreated(proposalId);
        return proposalId;
    }
    
    function castVote(uint256 proposalId, bool support) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == ProposalState.Active, "Proposal not active");
        require(block.number <= proposal.endBlock, "Voting ended");
        require(!hasVoted[proposalId][msg.sender], "Already voted");
        
        uint256 beingId = digitalBeing.addressToBeingId(msg.sender);
        require(beingId > 0, "Must own a Digital Being to vote");
        
        hasVoted[proposalId][msg.sender] = true;
        
        // ç®€å•çš„ 1 äºº 1 ç¥¨ï¼Œå¯ä»¥æ‰©å±•ä¸ºåŸºäºæŒæœ‰æ—¶é—´ç­‰çš„åŠ æƒæŠ•ç¥¨
        if (support) {
            proposal.forVotes++;
        } else {
            proposal.againstVotes++;
        }
        
        emit VoteCast(proposalId, msg.sender, support);
    }
    
    function execute(uint256 proposalId) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == ProposalState.Active, "Proposal not active");
        require(block.number > proposal.endBlock, "Voting not ended");
        
        if (proposal.forVotes > proposal.againstVotes) {
            proposal.state = ProposalState.Succeeded;
            
            // æ‰§è¡Œææ¡ˆ
            for (uint256 i = 0; i < proposal.targets.length; i++) {
                (bool success,) = proposal.targets[i].call(proposal.calldatas[i]);
                require(success, "Execution failed");
            }
            
            proposal.state = ProposalState.Executed;
            emit ProposalExecuted(proposalId);
        } else {
            proposal.state = ProposalState.Defeated;
        }
    }
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å¤šä¸ªå¸¸è§å¼€å‘åœºæ™¯çš„è¯¦ç»†æŒ‡å—ã€‚æ¯ä¸ªåœºæ™¯éƒ½åŒ…å«ï¼š

1. **éœ€æ±‚æè¿°** - æ˜ç¡®è¦å®ç°ä»€ä¹ˆ
2. **å¼€å‘æ­¥éª¤** - åˆ†æ­¥éª¤çš„å®ç°æŒ‡å—
3. **ä»£ç ç¤ºä¾‹** - å¯ç›´æ¥ä½¿ç”¨çš„ä»£ç 
4. **æµ‹è¯•æ–¹æ³•** - å¦‚ä½•éªŒè¯å®ç°
5. **æ³¨æ„äº‹é¡¹** - éœ€è¦æ³¨æ„çš„é—®é¢˜

### è¿›ä¸€æ­¥å­¦ä¹ 

- å‚è€ƒ [å¼€å‘æ‰‹å†Œ.md](./å¼€å‘æ‰‹å†Œ.md) äº†è§£åŸºç¡€çŸ¥è¯†
- æŸ¥çœ‹ [APIå‚è€ƒæ‰‹å†Œ.md](./APIå‚è€ƒæ‰‹å†Œ.md) äº†è§£ API è¯¦æƒ…
- é˜…è¯» [å›¢é˜Ÿåä½œæŒ‡å—.md](./å›¢é˜Ÿåä½œæŒ‡å—.md) äº†è§£åä½œæµç¨‹

---

*æœ€åæ›´æ–°ï¼š2025-10-26*  
*ç‰ˆæœ¬ï¼š1.0.0*

