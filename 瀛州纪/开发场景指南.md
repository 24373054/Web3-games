# 《瀛州纪》开发场景指南

> 常见开发任务的实战指南

---

## 📚 目录

1. [场景1：添加新的NPC类型](#场景1添加新的npc类型)
2. [场景2：实现新的事件类型](#场景2实现新的事件类型)
3. [场景3：添加新的前端组件](#场景3添加新的前端组件)
4. [场景4：优化Gas消耗](#场景4优化gas消耗)
5. [场景5：集成新的AI服务](#场景5集成新的ai服务)
6. [场景6：添加DAO治理功能](#场景6添加dao治理功能)
7. [场景7：实现NFT市场](#场景7实现nft市场)
8. [场景8：部署到新网络](#场景8部署到新网络)

---

## 场景1：添加新的NPC类型

### 需求描述
添加一个新的NPC类型："守护者（Guardian）"，负责保护世界的规则和秩序。

### 开发步骤

#### 步骤 1: 修改智能合约

```solidity
// contracts/AINPC.sol

// 1. 在 NPCType 枚举中添加新类型
enum NPCType {
    Archivist,
    Architect,
    Mercantile,
    Oracle,
    Entropy,
    Guardian    // 新增
}

// 2. 在 constructor 中初始化新 NPC
constructor(address _worldLedger) {
    // ... 其他 NPC 初始化
    
    // Guardian - 守护者
    bytes32 guardianId = keccak256(abi.encodePacked("Guardian"));
    npcs[guardianId] = NPC({
        id: guardianId,
        name: "Guardian",
        npcType: NPCType.Guardian,
        createdAt: block.timestamp,
        interactionCount: 0,
        degradationLevel: 0,
        isActive: true
    });
    npcIds.push(guardianId);
}
```

#### 步骤 2: 编写测试

```javascript
// test/AINPC.test.js

describe("Guardian NPC", function () {
  it("应该正确初始化 Guardian", async function () {
    const guardianId = await ainpc.getNPCId(5); // Guardian 的索引
    const guardian = await ainpc.getNPC(guardianId);
    
    expect(guardian.name).to.equal("Guardian");
    expect(guardian.npcType).to.equal(5);
    expect(guardian.isActive).to.equal(true);
  });

  it("应该能与 Guardian 交互", async function () {
    const guardianId = await ainpc.getNPCId(5);
    const questionHash = ethers.keccak256(
      ethers.toUtf8Bytes("守护者，世界的规则是什么？")
    );

    await expect(
      ainpc.interact(guardianId, questionHash)
    ).to.emit(ainpc, "NPCInteraction");

    const guardian = await ainpc.getNPC(guardianId);
    expect(guardian.interactionCount).to.equal(1);
  });
});
```

#### 步骤 3: 添加AI提示词

```typescript
// lib/ai.ts

const NPC_PROMPTS = {
  // ... 其他 NPC
  
  Guardian: `你是瀛州文明的守护者（Guardian）。

你的职责：
- 维护世界的规则和秩序
- 保护数字生命的权利
- 仲裁冲突和纠纷
- 确保系统的公平性

你的特点：
- 公正严明，不偏不倚
- 深刻理解世界的运行规则
- 语言正式且有威严感
- 引用具体的合约代码和逻辑

回答风格：
- 使用"本守护者"自称
- 引用具体的规则条款
- 保持中立和客观
- 偶尔引用代码片段说明规则

当前世界状态：{worldState}
熵化程度：{entropyLevel}%

注意：
- 如果熵化程度 > 60%，你的判断可能开始出现混乱
- 如果熵化程度 > 80%，你可能无法维持秩序

请回答用户的问题（50-200字）：`,
};
```

#### 步骤 4: 更新前端组件

```typescript
// components/NPCList.tsx

const NPC_INFO = {
  // ... 其他 NPC
  
  Guardian: {
    name: '守护者',
    icon: '🛡️',
    description: '维护世界秩序，保护规则运行',
    color: 'text-blue-400'
  }
};

// 在组件中添加 Guardian
<div 
  className="npc-card guardian"
  onClick={() => onSelectNPC('Guardian')}
>
  <span className="text-4xl">{NPC_INFO.Guardian.icon}</span>
  <h3 className="text-xl font-bold text-blue-400">
    {NPC_INFO.Guardian.name}
  </h3>
  <p className="text-sm text-gray-400">
    {NPC_INFO.Guardian.description}
  </p>
</div>
```

#### 步骤 5: 更新叙事内容

```json
// data/worldNarrative.json

{
  "npcs": {
    // ... 其他 NPC
    
    "Guardian": {
      "name": "守护者",
      "role": "规则维护者",
      "background": "在世界创立之初，为了维持秩序而诞生的智能体...",
      "dialogues": {
        "greeting": "本守护者感知到你的存在。此处是规则之域，秩序之所。",
        "about_rules": "世界的规则由 WorldLedger 合约定义...",
        "about_conflict": "当冲突发生时，本守护者会依据合约逻辑进行仲裁..."
      }
    }
  }
}
```

#### 步骤 6: 重新部署和测试

```bash
# 1. 编译合约
npm run compile

# 2. 运行测试
npm test

# 3. 部署到本地网络
npx hardhat node  # 终端 1
npm run deploy    # 终端 2

# 4. 更新前端配置
# 复制新的合约地址到 .env.local

# 5. 启动前端测试
npm run dev

# 6. 手动测试
# - 选择 Guardian NPC
# - 发送测试消息
# - 验证 AI 响应
# - 检查链上交互记录
```

#### 步骤 7: 文档更新

```markdown
// README.md

### AI-NPC 类型

- 📜 **史官（Archivist）** - 记录和讲述历史
- 🔨 **工匠（Architect）** - 解释世界的构造规则
- ⚖️ **商序（Mercantile）** - 管理资源和交易
- 🔮 **先知（Oracle）** - 预测和推演未来
- 🌀 **遗忘（Entropy）** - 代表记忆的崩塌
- 🛡️ **守护者（Guardian）** - 维护规则和秩序  // 新增
```

---

## 场景2：实现新的事件类型

### 需求描述
添加"资源交换（Exchange）"事件类型，记录数字生命之间的资源交换。

### 开发步骤

#### 步骤 1: 扩展事件枚举

```solidity
// contracts/WorldLedger.sol

enum EventType {
    Creation,
    Interaction,
    Discovery,
    Conflict,
    Memory,
    Exchange    // 新增
}
```

#### 步骤 2: 添加资源管理合约（可选）

```solidity
// contracts/ResourceManager.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./WorldLedger.sol";

contract ResourceManager {
    WorldLedger public worldLedger;
    
    // 资源类型
    enum ResourceType {
        Energy,      // 能量
        Data,        // 数据
        Logic        // 逻辑
    }
    
    // 资源余额
    mapping(address => mapping(ResourceType => uint256)) public balances;
    
    event ResourceExchanged(
        address indexed from,
        address indexed to,
        ResourceType resourceType,
        uint256 amount,
        uint256 eventId
    );
    
    constructor(address _worldLedger) {
        worldLedger = WorldLedger(_worldLedger);
    }
    
    /**
     * @dev 交换资源
     */
    function exchange(
        address to,
        ResourceType resourceType,
        uint256 amount
    ) external {
        require(to != address(0), "Invalid recipient");
        require(balances[msg.sender][resourceType] >= amount, "Insufficient balance");
        
        // 转移资源
        balances[msg.sender][resourceType] -= amount;
        balances[to][resourceType] += amount;
        
        // 记录到世界账本
        bytes32 contentHash = keccak256(
            abi.encodePacked(msg.sender, to, resourceType, amount, block.timestamp)
        );
        
        string memory metadata = string(abi.encodePacked(
            '{"from":"', _addressToString(msg.sender),
            '","to":"', _addressToString(to),
            '","resourceType":', _uint2str(uint256(resourceType)),
            ',"amount":', _uint2str(amount),
            '}'
        ));
        
        uint256 eventId = worldLedger.recordEvent(
            WorldLedger.EventType.Exchange,
            contentHash,
            metadata
        );
        
        emit ResourceExchanged(msg.sender, to, resourceType, amount, eventId);
    }
    
    /**
     * @dev 铸造资源（测试用）
     */
    function mint(address to, ResourceType resourceType, uint256 amount) external {
        balances[to][resourceType] += amount;
    }
    
    // 辅助函数
    function _addressToString(address addr) internal pure returns (string memory) {
        // 转换地址为字符串
        // 实现略
    }
    
    function _uint2str(uint256 _i) internal pure returns (string memory) {
        // 转换 uint 为字符串
        // 实现略
    }
}
```

#### 步骤 3: 编写测试

```javascript
// test/ResourceManager.test.js

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ResourceManager", function () {
  let resourceManager, worldLedger;
  let owner, addr1, addr2;

  beforeEach(async function () {
    [owner, addr1, addr2] = await ethers.getSigners();
    
    // 部署 WorldLedger
    const WorldLedger = await ethers.getContractFactory("WorldLedger");
    worldLedger = await WorldLedger.deploy();
    
    // 部署 ResourceManager
    const ResourceManager = await ethers.getContractFactory("ResourceManager");
    resourceManager = await ResourceManager.deploy(await worldLedger.getAddress());
    
    // 注册 ResourceManager 为 DigitalBeing
    await worldLedger.registerDigitalBeing(await resourceManager.getAddress());
  });

  describe("资源交换", function () {
    beforeEach(async function () {
      // 给 addr1 铸造一些资源
      await resourceManager.mint(addr1.address, 0, 1000); // Energy
    });

    it("应该成功交换资源", async function () {
      await resourceManager.connect(addr1).exchange(
        addr2.address,
        0, // Energy
        100
      );

      expect(await resourceManager.balances(addr1.address, 0)).to.equal(900);
      expect(await resourceManager.balances(addr2.address, 0)).to.equal(100);
    });

    it("应该记录交换事件到 WorldLedger", async function () {
      await expect(
        resourceManager.connect(addr1).exchange(addr2.address, 0, 100)
      ).to.emit(worldLedger, "EventRecorded");

      const eventCount = await worldLedger.eventCounter();
      const event = await worldLedger.events(eventCount);
      
      expect(event.eventType).to.equal(5); // Exchange
      
      const metadata = JSON.parse(event.metadata);
      expect(metadata.from).to.equal(addr1.address.toLowerCase());
      expect(metadata.to).to.equal(addr2.address.toLowerCase());
      expect(metadata.amount).to.equal("100");
    });

    it("余额不足时应该失败", async function () {
      await expect(
        resourceManager.connect(addr1).exchange(addr2.address, 0, 2000)
      ).to.be.revertedWith("Insufficient balance");
    });
  });
});
```

#### 步骤 4: 前端集成

```typescript
// components/ResourceExchange.tsx
'use client';

import React, { useState } from 'react';
import { ethers } from 'ethers';
import { getContract } from '@/lib/contracts';

export function ResourceExchange() {
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');
  const [resourceType, setResourceType] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  const handleExchange = async () => {
    try {
      setIsLoading(true);

      // 验证地址
      if (!ethers.isAddress(recipient)) {
        alert('无效的地址');
        return;
      }

      // 获取合约
      const provider = new ethers.BrowserProvider(window.ethereum);
      const signer = await provider.getSigner();
      const resourceManager = getContract('ResourceManager', signer);

      // 执行交换
      const tx = await resourceManager.exchange(
        recipient,
        resourceType,
        ethers.parseUnits(amount, 0)
      );

      console.log('交易已发送:', tx.hash);
      const receipt = await tx.wait();
      console.log('交易已确认:', receipt.blockNumber);

      alert('资源交换成功！');
      
      // 重置表单
      setRecipient('');
      setAmount('');
    } catch (error: any) {
      console.error('交换失败:', error);
      alert(`交换失败: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="p-6 bg-gray-800 rounded-lg border border-cyan-500/30">
      <h3 className="text-xl font-bold text-cyan-400 mb-4">资源交换</h3>
      
      <div className="space-y-4">
        {/* 资源类型选择 */}
        <div>
          <label className="block text-sm text-gray-400 mb-2">
            资源类型
          </label>
          <select
            value={resourceType}
            onChange={(e) => setResourceType(Number(e.target.value))}
            className="w-full px-4 py-2 bg-gray-900 border border-cyan-500/30 rounded"
          >
            <option value={0}>能量 (Energy)</option>
            <option value={1}>数据 (Data)</option>
            <option value={2}>逻辑 (Logic)</option>
          </select>
        </div>

        {/* 接收者地址 */}
        <div>
          <label className="block text-sm text-gray-400 mb-2">
            接收者地址
          </label>
          <input
            type="text"
            value={recipient}
            onChange={(e) => setRecipient(e.target.value)}
            placeholder="0x..."
            className="w-full px-4 py-2 bg-gray-900 border border-cyan-500/30 rounded"
          />
        </div>

        {/* 数量 */}
        <div>
          <label className="block text-sm text-gray-400 mb-2">
            数量
          </label>
          <input
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            placeholder="100"
            min="0"
            className="w-full px-4 py-2 bg-gray-900 border border-cyan-500/30 rounded"
          />
        </div>

        {/* 提交按钮 */}
        <button
          onClick={handleExchange}
          disabled={isLoading || !recipient || !amount}
          className="w-full px-6 py-3 bg-cyan-500 hover:bg-cyan-600 disabled:bg-gray-600 disabled:cursor-not-allowed rounded font-bold transition-colors"
        >
          {isLoading ? '交换中...' : '确认交换'}
        </button>
      </div>
    </div>
  );
}
```

#### 步骤 5: 更新部署脚本

```javascript
// scripts/deploy.js

// 部署 ResourceManager
console.log("部署 ResourceManager...");
const ResourceManager = await ethers.getContractFactory("ResourceManager");
const resourceManager = await ResourceManager.deploy(
  await worldLedger.getAddress()
);
await resourceManager.waitForDeployment();
console.log("ResourceManager 部署到:", await resourceManager.getAddress());

// 注册为 DigitalBeing
await worldLedger.registerDigitalBeing(await resourceManager.getAddress());
console.log("ResourceManager 已注册");

// 输出所有地址
console.log("\n部署完成！");
console.log("=================================");
console.log("WorldLedger:", await worldLedger.getAddress());
console.log("DigitalBeing:", await digitalBeing.getAddress());
console.log("AINPC:", await ainpc.getAddress());
console.log("ResourceManager:", await resourceManager.getAddress());  // 新增
console.log("=================================");
```

---

## 场景3：添加新的前端组件

### 需求描述
创建一个"世界地图"组件，可视化显示数字生命的分布和交互关系。

### 开发步骤

#### 步骤 1: 设计组件结构

```typescript
// components/WorldMap.tsx
'use client';

import React, { useEffect, useState, useRef } from 'react';
import { ethers } from 'ethers';
import { getContract } from '@/lib/contracts';

interface Node {
  id: string;
  x: number;
  y: number;
  type: 'being' | 'npc';
  data: any;
}

interface Link {
  source: string;
  target: string;
  strength: number;
}

export function WorldMap() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [nodes, setNodes] = useState<Node[]>([]);
  const [links, setLinks] = useState<Link[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadWorldData();
  }, []);

  useEffect(() => {
    if (nodes.length > 0) {
      renderMap();
    }
  }, [nodes, links]);

  const loadWorldData = async () => {
    try {
      const provider = new ethers.BrowserProvider(window.ethereum);
      
      // 获取合约
      const digitalBeing = getContract('DigitalBeing', provider);
      const ainpc = getContract('AINPC', provider);
      const worldLedger = getContract('WorldLedger', provider);

      // 加载所有 NPC
      const allNPCs = await ainpc.getAllNPCs();
      const npcNodes: Node[] = allNPCs.map((npc, index) => ({
        id: `npc-${npc.id}`,
        x: 400 + Math.cos(index * Math.PI / 3) * 200,
        y: 300 + Math.sin(index * Math.PI / 3) * 200,
        type: 'npc',
        data: npc
      }));

      // 加载最近的事件，提取参与的 Being
      const recentEvents = await worldLedger.getRecentEvents(50);
      const beingAddresses = new Set<string>();
      recentEvents.forEach(event => {
        if (event.actor !== ethers.ZeroAddress) {
          beingAddresses.add(event.actor);
        }
      });

      // 加载 Being 信息
      const beingNodes: Node[] = [];
      for (const address of Array.from(beingAddresses)) {
        const beingId = await digitalBeing.addressToBeingId(address);
        if (beingId > 0) {
          const being = await digitalBeing.reflect(beingId);
          beingNodes.push({
            id: `being-${beingId}`,
            x: Math.random() * 600 + 100,
            y: Math.random() * 400 + 100,
            type: 'being',
            data: being
          });
        }
      }

      // 构建连接关系（基于交互次数）
      const linkMap = new Map<string, number>();
      // 分析事件构建链接...

      setNodes([...npcNodes, ...beingNodes]);
      setIsLoading(false);
    } catch (error) {
      console.error('加载世界数据失败:', error);
      setIsLoading(false);
    }
  };

  const renderMap = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // 清空画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 绘制背景网格
    drawGrid(ctx);

    // 绘制连接线
    links.forEach(link => {
      const sourceNode = nodes.find(n => n.id === link.source);
      const targetNode = nodes.find(n => n.id === link.target);
      if (sourceNode && targetNode) {
        drawLink(ctx, sourceNode, targetNode, link.strength);
      }
    });

    // 绘制节点
    nodes.forEach(node => {
      if (node.type === 'npc') {
        drawNPCNode(ctx, node);
      } else {
        drawBeingNode(ctx, node);
      }
    });
  };

  const drawGrid = (ctx: CanvasRenderingContext2D) => {
    ctx.strokeStyle = 'rgba(6, 182, 212, 0.1)';
    ctx.lineWidth = 1;

    // 垂直线
    for (let x = 0; x < 800; x += 50) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, 600);
      ctx.stroke();
    }

    // 水平线
    for (let y = 0; y < 600; y += 50) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(800, y);
      ctx.stroke();
    }
  };

  const drawLink = (
    ctx: CanvasRenderingContext2D,
    source: Node,
    target: Node,
    strength: number
  ) => {
    ctx.strokeStyle = `rgba(6, 182, 212, ${strength / 100})`;
    ctx.lineWidth = 1 + strength / 50;
    ctx.beginPath();
    ctx.moveTo(source.x, source.y);
    ctx.lineTo(target.x, target.y);
    ctx.stroke();
  };

  const drawNPCNode = (ctx: CanvasRenderingContext2D, node: Node) => {
    // 外圈光晕
    const gradient = ctx.createRadialGradient(
      node.x, node.y, 0,
      node.x, node.y, 30
    );
    gradient.addColorStop(0, 'rgba(168, 85, 247, 0.4)');
    gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(node.x - 30, node.y - 30, 60, 60);

    // 内圈节点
    ctx.fillStyle = '#a855f7';
    ctx.beginPath();
    ctx.arc(node.x, node.y, 15, 0, Math.PI * 2);
    ctx.fill();

    // 文字标签
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(node.data.name || 'NPC', node.x, node.y - 25);
  };

  const drawBeingNode = (ctx: CanvasRenderingContext2D, node: Node) => {
    // 外圈光晕
    const gradient = ctx.createRadialGradient(
      node.x, node.y, 0,
      node.x, node.y, 25
    );
    gradient.addColorStop(0, 'rgba(6, 182, 212, 0.4)');
    gradient.addColorStop(1, 'rgba(6, 182, 212, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(node.x - 25, node.y - 25, 50, 50);

    // 内圈节点
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.arc(node.x, node.y, 10, 0, Math.PI * 2);
    ctx.fill();

    // ID 标签
    ctx.fillStyle = '#fff';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`#${node.data.id}`, node.x, node.y + 25);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-96">
        <div className="text-cyan-400">加载世界地图...</div>
      </div>
    );
  }

  return (
    <div className="p-6 bg-gray-900 rounded-lg border border-cyan-500/30">
      <h3 className="text-xl font-bold text-cyan-400 mb-4">
        世界地图
      </h3>
      
      <div className="relative">
        <canvas
          ref={canvasRef}
          width={800}
          height={600}
          className="w-full border border-cyan-500/20 rounded"
        />
        
        <div className="mt-4 flex items-center gap-6 text-sm">
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded-full bg-cyan-500" />
            <span className="text-gray-400">数字生命</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded-full bg-purple-500" />
            <span className="text-gray-400">AI-NPC</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-8 h-0.5 bg-cyan-500/50" />
            <span className="text-gray-400">交互连接</span>
          </div>
        </div>
      </div>
    </div>
  );
}
```

#### 步骤 2: 在页面中使用

```typescript
// app/page.tsx

import { WorldMap } from '@/components/WorldMap';

export default function Home() {
  return (
    <div className="container mx-auto px-4 py-8">
      {/* ... 其他组件 ... */}
      
      <div className="mt-8">
        <WorldMap />
      </div>
    </div>
  );
}
```

---

## 场景4：优化Gas消耗

### 需求描述
优化 `WorldLedger.recordEvent` 函数的 Gas 消耗。

### 优化步骤

#### 步骤 1: 分析当前Gas消耗

```bash
# 运行 Gas 报告
REPORT_GAS=true npx hardhat test
```

#### 步骤 2: 识别优化点

```solidity
// contracts/WorldLedger.sol

// ❌ 优化前
function recordEvent(
    EventType eventType,
    bytes32 contentHash,
    string calldata metadata
) external onlyDigitalBeing notFinalized returns (uint256) {
    eventCounter++;  // SSTORE: 5000 gas
    
    HistoricalEvent memory newEvent = HistoricalEvent({
        id: eventCounter,
        timestamp: block.timestamp,
        blockNumber: block.number,
        eventType: eventType,
        actor: msg.sender,
        contentHash: contentHash,
        metadata: metadata,  // 字符串存储昂贵
        isSealed: false
    });
    
    events[eventCounter] = newEvent;  // 多次 SSTORE
    beingEvents[msg.sender].push(eventCounter);  // 动态数组 push 昂贵
    
    emit EventRecorded(eventCounter, eventType, msg.sender);
    
    return eventCounter;
}
```

#### 步骤 3: 应用优化

```solidity
// ✅ 优化后
function recordEvent(
    EventType eventType,
    bytes32 contentHash,
    string calldata metadata
) external onlyDigitalBeing notFinalized returns (uint256) {
    uint256 eventId;
    unchecked {
        eventId = ++eventCounter;  // 使用 unchecked 节省 gas
    }
    
    // 直接分配字段而不是创建内存结构体
    HistoricalEvent storage newEvent = events[eventId];
    newEvent.id = eventId;
    newEvent.timestamp = block.timestamp;
    newEvent.blockNumber = block.number;
    newEvent.eventType = eventType;
    newEvent.actor = msg.sender;
    newEvent.contentHash = contentHash;
    // 注意：metadata 仍然需要存储，但这是必要的
    newEvent.metadata = metadata;
    newEvent.isSealed = false;
    
    // 只在需要时才更新 beingEvents
    // 或者考虑使用事件代替存储
    beingEvents[msg.sender].push(eventId);
    
    // 事件是便宜的
    emit EventRecorded(eventId, eventType, msg.sender);
    
    return eventId;
}

// 进一步优化：考虑将 metadata 移到链下
function recordEventOptimized(
    EventType eventType,
    bytes32 contentHash,
    bytes32 metadataHash  // 只存储哈希
) external onlyDigitalBeing notFinalized returns (uint256) {
    uint256 eventId;
    unchecked {
        eventId = ++eventCounter;
    }
    
    // 只存储关键数据
    events[eventId] = HistoricalEvent({
        id: eventId,
        timestamp: block.timestamp,
        blockNumber: block.number,
        eventType: eventType,
        actor: msg.sender,
        contentHash: contentHash,
        metadata: "",  // 空字符串
        isSealed: false
    });
    
    // 通过事件记录完整元数据（链下可以索引）
    emit EventRecordedWithMetadata(
        eventId,
        eventType,
        msg.sender,
        metadataHash
    );
    
    return eventId;
}
```

#### 步骤 4: 测试优化效果

```javascript
// test/GasOptimization.test.js

describe("Gas 优化测试", function () {
  it("对比优化前后的 Gas 消耗", async function () {
    // 优化前
    const tx1 = await worldLedger.recordEvent(
      0,
      ethers.keccak256(ethers.toUtf8Bytes("test")),
      "这是一段很长的元数据" + "x".repeat(100)
    );
    const receipt1 = await tx1.wait();
    console.log("优化前 Gas:", receipt1.gasUsed.toString());

    // 优化后
    const tx2 = await worldLedger.recordEventOptimized(
      0,
      ethers.keccak256(ethers.toUtf8Bytes("test")),
      ethers.keccak256(ethers.toUtf8Bytes("metadata hash"))
    );
    const receipt2 = await tx2.wait();
    console.log("优化后 Gas:", receipt2.gasUsed.toString());

    // 计算节省的百分比
    const saved = receipt1.gasUsed - receipt2.gasUsed;
    const percentage = (saved * 100n) / receipt1.gasUsed;
    console.log(`节省了 ${percentage}% 的 Gas`);
  });
});
```

---

## 场景5：集成新的AI服务

### 需求描述
从模拟 AI 切换到真实的魔搭 AI 服务。

### 集成步骤

#### 步骤 1: 获取 API 密钥

1. 访问 [魔搭平台](https://www.modelscope.cn/)
2. 注册账号并登录
3. 进入"API密钥"页面
4. 创建新的 API 密钥

#### 步骤 2: 配置环境变量

```env
# .env.local
AI_API_KEY=sk-xxxxxxxxxxxxxxxxxx
AI_API_URL=https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation
AI_MODEL=qwen-plus
```

#### 步骤 3: 更新 AI 服务代码

```typescript
// lib/ai.ts

interface AIMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export async function generateAIResponse(
  npcType: NPCType,
  message: string,
  context?: {
    worldState?: number;
    entropyLevel?: number;
  }
): Promise<string> {
  // 构建系统提示
  const systemPrompt = getNPCPrompt(
    npcType,
    context?.worldState || 0,
    context?.entropyLevel || 0
  );

  // 准备消息
  const messages: AIMessage[] = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: message }
  ];

  try {
    // 调用魔搭 API
    const response = await fetch(process.env.AI_API_URL!, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.AI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: process.env.AI_MODEL || 'qwen-plus',
        input: {
          messages: messages
        },
        parameters: {
          temperature: 0.7,
          top_p: 0.9,
          max_tokens: 500
        }
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`AI API 错误: ${error.message}`);
    }

    const data = await response.json();
    
    // 提取响应文本
    const aiResponse = data.output.text || data.output.choices[0].message.content;
    
    // 应用衰变效果
    const degradedResponse = applyDegradation(
      aiResponse,
      context?.entropyLevel || 0
    );
    
    return degradedResponse;
  } catch (error) {
    console.error('AI 生成失败:', error);
    
    // 降级到模拟响应
    return getSimulatedResponse(npcType, message);
  }
}

// 模拟响应（作为后备）
function getSimulatedResponse(npcType: NPCType, message: string): string {
  const responses: Record<NPCType, string> = {
    Archivist: '[模拟响应] 作为史官，我记录着瀛州的历史...',
    Architect: '[模拟响应] 作为工匠，我维护着世界的规则...',
    Mercantile: '[模拟响应] 作为商序，我管理着资源的流动...',
    Oracle: '[模拟响应] 作为先知，我预见着可能的未来...',
    Entropy: '[模拟响应] ...记忆...崩塌...'
  };
  
  return responses[npcType] || '[模拟响应] 系统暂时无法响应';
}
```

#### 步骤 4: 添加错误处理和重试

```typescript
// lib/ai.ts

async function fetchWithRetry(
  url: string,
  options: RequestInit,
  maxRetries: number = 3
): Promise<Response> {
  let lastError: Error;

  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, {
        ...options,
        signal: AbortSignal.timeout(30000) // 30秒超时
      });
      
      if (response.ok) {
        return response;
      }
      
      // 如果是速率限制，等待后重试
      if (response.status === 429) {
        const retryAfter = parseInt(response.headers.get('Retry-After') || '5');
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        continue;
      }
      
      // 其他错误直接抛出
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    } catch (error) {
      lastError = error as Error;
      console.warn(`请求失败 (尝试 ${i + 1}/${maxRetries}):`, error);
      
      // 指数退避
      if (i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
      }
    }
  }

  throw lastError!;
}
```

#### 步骤 5: 测试集成

```typescript
// 创建测试页面
// app/debug/ai-test/page.tsx

'use client';

import { useState } from 'react';
import { generateAIResponse } from '@/lib/ai';

export default function AITestPage() {
  const [message, setMessage] = useState('');
  const [response, setResponse] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleTest = async () => {
    try {
      setIsLoading(true);
      setResponse('');
      
      const result = await generateAIResponse(
        'Archivist',
        message,
        { worldState: 2, entropyLevel: 30 }
      );
      
      setResponse(result);
    } catch (error: any) {
      setResponse(`错误: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-8">
      <h1 className="text-2xl font-bold mb-4">AI 服务测试</h1>
      
      <div className="space-y-4">
        <textarea
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="输入测试消息..."
          className="w-full h-32 p-4 bg-gray-900 border border-cyan-500/30 rounded"
        />
        
        <button
          onClick={handleTest}
          disabled={isLoading || !message}
          className="px-6 py-3 bg-cyan-500 hover:bg-cyan-600 disabled:bg-gray-600 rounded font-bold"
        >
          {isLoading ? '生成中...' : '测试 AI'}
        </button>
        
        {response && (
          <div className="p-4 bg-gray-900 border border-cyan-500/30 rounded">
            <h3 className="font-bold mb-2">AI 响应：</h3>
            <p className="whitespace-pre-wrap">{response}</p>
          </div>
        )}
      </div>
    </div>
  );
}
```

---

## 场景6：添加DAO治理功能

详细的 DAO 治理实现超出了本文档的范围，但这里提供一个基本框架：

### 核心合约

```solidity
// contracts/Governance.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./WorldLedger.sol";
import "./DigitalBeing.sol";

contract Governance {
    WorldLedger public worldLedger;
    DigitalBeing public digitalBeing;
    
    enum ProposalState {
        Pending,
        Active,
        Succeeded,
        Defeated,
        Executed
    }
    
    struct Proposal {
        uint256 id;
        address proposer;
        string description;
        uint256 startBlock;
        uint256 endBlock;
        uint256 forVotes;
        uint256 againstVotes;
        ProposalState state;
        bytes[] calldatas;
        address[] targets;
    }
    
    // 提案
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalCount;
    
    // 投票记录
    mapping(uint256 => mapping(address => bool)) public hasVoted;
    
    event ProposalCreated(uint256 indexed proposalId);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support);
    event ProposalExecuted(uint256 indexed proposalId);
    
    constructor(address _worldLedger, address _digitalBeing) {
        worldLedger = WorldLedger(_worldLedger);
        digitalBeing = DigitalBeing(_digitalBeing);
    }
    
    function propose(
        string calldata description,
        address[] calldata targets,
        bytes[] calldata calldatas
    ) external returns (uint256) {
        // 检查提案者是否拥有 Digital Being
        require(
            digitalBeing.addressToBeingId(msg.sender) > 0,
            "Must own a Digital Being to propose"
        );
        
        proposalCount++;
        uint256 proposalId = proposalCount;
        
        proposals[proposalId] = Proposal({
            id: proposalId,
            proposer: msg.sender,
            description: description,
            startBlock: block.number,
            endBlock: block.number + 40320, // ~7 days
            forVotes: 0,
            againstVotes: 0,
            state: ProposalState.Active,
            calldatas: calldatas,
            targets: targets
        });
        
        emit ProposalCreated(proposalId);
        return proposalId;
    }
    
    function castVote(uint256 proposalId, bool support) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == ProposalState.Active, "Proposal not active");
        require(block.number <= proposal.endBlock, "Voting ended");
        require(!hasVoted[proposalId][msg.sender], "Already voted");
        
        uint256 beingId = digitalBeing.addressToBeingId(msg.sender);
        require(beingId > 0, "Must own a Digital Being to vote");
        
        hasVoted[proposalId][msg.sender] = true;
        
        // 简单的 1 人 1 票，可以扩展为基于持有时间等的加权投票
        if (support) {
            proposal.forVotes++;
        } else {
            proposal.againstVotes++;
        }
        
        emit VoteCast(proposalId, msg.sender, support);
    }
    
    function execute(uint256 proposalId) external {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == ProposalState.Active, "Proposal not active");
        require(block.number > proposal.endBlock, "Voting not ended");
        
        if (proposal.forVotes > proposal.againstVotes) {
            proposal.state = ProposalState.Succeeded;
            
            // 执行提案
            for (uint256 i = 0; i < proposal.targets.length; i++) {
                (bool success,) = proposal.targets[i].call(proposal.calldatas[i]);
                require(success, "Execution failed");
            }
            
            proposal.state = ProposalState.Executed;
            emit ProposalExecuted(proposalId);
        } else {
            proposal.state = ProposalState.Defeated;
        }
    }
}
```

---

## 总结

本文档提供了多个常见开发场景的详细指南。每个场景都包含：

1. **需求描述** - 明确要实现什么
2. **开发步骤** - 分步骤的实现指南
3. **代码示例** - 可直接使用的代码
4. **测试方法** - 如何验证实现
5. **注意事项** - 需要注意的问题

### 进一步学习

- 参考 [开发手册.md](./开发手册.md) 了解基础知识
- 查看 [API参考手册.md](./API参考手册.md) 了解 API 详情
- 阅读 [团队协作指南.md](./团队协作指南.md) 了解协作流程

---

*最后更新：2025-10-26*  
*版本：1.0.0*

